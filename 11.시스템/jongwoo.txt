스터디

시스템

- 도시를 세운다면? - 도시는 한사람만의 힘으로는 세우거나 직접 관리할 수 없다 - 각 분야를 담당하는 팀이 있기 때문에 도시가 돌아간다. - 소프트웨어팀도 도시처럼 구성한다. - 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다. 
- 시스템 제작과 시스템 사용을 분리하라 - 제작과 사용은 아주 다르다. - 시작 단계는 모든 애플리케이션이 풀어야할 관심사다. 관심사 분리는 우리 분야에서 가장 오래되고 가장 중요한 설계 기법 중 하나다.  - 초기화 지연 or 계산 지연의 장점    - 실제로 필요할때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.    - 어떤 경우에도 null 포인터를 반환하지않는다. - 초기화 지연 or 계산 지연의 단점    - 메서드가 생성자 인수에 명시적으로 의존한다.    - 단위 테스트에서 메서드를 호출하기 전에 적절한 테스트 전용 객체를 할당해야한다.    - 일반 런타임 로직에다 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로도 테스트 해야한다.  - 초기화 지연기법을 한 번 정도 사용한다면 별로 심각한 문제가 아니다. - 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안된다. 
- Main 분리 - 시스템 생성과 시스템 사용을 분리하는 한가지 방법 - 생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다. - 애플리케이션은 main이나 객체가 생성되는 과정을 전현 모른다. 
- 팩토리 - 객체가 생성되는 시점을 어플리케이션이 결정할 필요도 생긴다. 
- 의존성 주입 - 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입이다. - 의존성 주입은 제어역전 기법을 의존성 관리에 적용한 메커니즘이다. - 단일 책임 원칙을 지키게 된다. - 의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다. 대신에 이런 책임을 다른 ‘전담’ 메커니즘에 넘겨야 한다. - 진정한 의존성 주입은 클래스가 의존성을 해결하려 시도하지 않는다. 대신에 의존성을 주입하는 방법으로 성정자(setter) 메서드나 생성자 인수를 제공한다. 
- 확장 - 언제나 작은 것부터 시작하여 점차 성장하며 결국 큰 결과물로 따른다. - 하지만 언제나 성장에는 고통이 따른다. ‘확장’ 공사로 꽉막힌 도로가 처음부터 넓게 만들지 않았는지라고 궁금했던적이 많았을 것이다. - 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신이다. - TDD, 리펙토링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다. - 영구 저장소에서 객체와 관계형 자료가 매핑되는 방식, 원하는 트랜잭션 동작, 보안 제약조건 등이 들어가는 XML 배포 기술자를 작성해야 한다. 
- 횡단 관심사 - 영속성과 같은 관심사는 어플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다. - 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다. - 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. - 하지만 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 ‘횡단 관심사’ 라는 용어가 나온다. - 관점 지향 프로그래밍 - AOP(Aspect-Oriented Programming)는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다. - AOP에서 관점이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성있게 바꿔야 한다”라고 명시한다. 
- 자바 프록시 - 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예인 자바 프록시는 단순한 상황에 적합하다. - 클래스 프록시를 사용하려면 CGLIB, ASM, Javassist등과 같은 바이트 코드 처리 라이브러리가 필요하다. - 프록시를 사용하려면 깨끗한 코드를 작성하기 어렵다. 또한 프록시는 시스템 단위로 실행 지점을 명시하는 메커니즘도 제공하지 않는다. 
- 순수 자바 AOP 프레임워크 - 대부분의 프록시 코드는 판박이라 도구로 자동화할 수 있다. - 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP등 과 같은 여러 자바 프레임워크는 내부적으로 프록시를 사용한다.  - POJO    - POJO는 순수하게 도메인에 초점을 맞춘다. 또한 엔터프라이즈 프레임워크에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단하다.    - 상대적으로 단순하기 때문에 사용자 스토리를 올바로 구현하기 쉬우며 미래 스토리에 맞춰 코드를 보수하고 개선하기 편하다.  - 프로그래머는 설정 파일이나 API를 사용해 필수적인 어플리케이션 기반 구조를 구현한다. - 일부 상세한 엔티티 정보는 애너테이션에 포함되어 그대로 남아있지만, 모든 정보가 애너테이션 속에 있으므로 코드 자체는 깔끔하고 깨끗하다. 
- AspectJ 관점 - 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ언어다. 언어차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다. - AspectJ의 단점으로는 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 것이다. - 최근에 나온 AspectJ ‘애너테이션 폼’은 새로운 도구와 새로운 언어라는 부담을 어느정도 완화한다. 
- 테스트 주도 시스템 아키텍쳐 구축 - 관점으로 관심사를 분리하는 방식은 그 위력이 막강하다.  - 어플이케이션 도메인 논리를 POJO로 작성할 수 있다면( 코드 수준에서 아키텍쳐 관심사를 분리할 수 있다면 ), 진정한 테스트 주도 아키텍쳐 구축이 가능해진다.  - BDUF    - 건축가는 BDUF(Big Design Up Front)방식을 추구한다. 물리적 구조는 일단 짓기 시작하면 극적인 변경이 불가능한 탓이다.    - 소프트웨어 역시 나름대로 형체가 있지만, 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다.  - 아주 단순하면서도 멋지게 분리된 아키텍쳐로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하여 조금씩 확장해나가도 괜찮다는 말이다.  -> 안드로이드로 비유한다면 플러터로 개발하여 빠르게 출시한후 투자금을 모아 안드로이드&IOS 네이티브로 재개발 하는것이 맞을까요? 뭐 아니면 말고. 딱 이생각이 나서 그런데 스터디때 결과좀 알려줘요~  - 그렇다고 아무 방향없이 프로젝트에 뛰어들어도 좋다는 소리는 아니다. - 프로젝트를 시작할때 일반적인 범위, 목표 ,일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 란다. - 하지만 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.  - 요약    - 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역으로 구성된다.    - 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다.    - 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다. 
- 의사 결정을 최적화 하라 - 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. - 우리는 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이라는 사실을 까먹곤 한다. - 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. - 이런 기민함 덕에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기 쉬워진다. 또한 결정의 복잡성도 줄어든다. 
- 명백한 가치가 있을 때 표준을 현명하게 사용하라 - 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. - 하지만 때로는 표준을 만드는 시간이 너무 오래걸려 업계가 기다리지 못한다. 
- 시스템은 도메인 특화 언어가 필요하다. - DSL(Domain Specific Language)은 간단한 스크립트 언어나 표준언어로 구현한 API를 가리킨다. - DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힌다. - 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 ‘의사소통 간극’을 줄여준다. - 효과적으로 사용한다면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다. 그래서 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다.  
- 결론 - 시스템은 당연하겠지만 깨끗해야 한다. 깨끗하지 못한 아키텍쳐는 도메인 논리를 흐리며 기민성을 떨얻드린다. - 도메인 논리가 흐려지면 제품 품질이 떨어진다. - 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다. - 시스템을 설계하든, 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야한다.

# 시스템

## 도시를 세운다면?
도시를 혼자서 직접 관리하는 것은 불가능함. 그럼에도 도시가 잘 돌아가는 이유는
- 큰 그림을 그리는 사람뿐만 아니라 작은 사항에 집중하는 사람들
- 개인이 관리하는 구성요소를 효율적으로 돌아가게하는 적절한 추상화와 모듈화

## 시스템 제작과 사용을 분리하라
- **제작**과 **사용**은 매우 다름
- **시작 단계**라는 관심사를 모든 애플리케이션이 풀어야 함

```java

public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);
    
  return service;
}

```
- 초기화 지연 혹은 계산 지연이라는 기법을 이용해 런타임에서 실제로 필요하기 전까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않음  
- 런타임 로직에서 해당 객체를 전혀 사용하지 않더라도 해당 객체에 대한 의존성이 생김
- 테스트에서도 테스트 전용 객체를 할당해야 하는 문제가 있음

## Main 분리
<img width="500" src="https://user-images.githubusercontent.com/50200481/205482490-cc8e0b74-487d-4b78-a3c0-9949c902243b.png">

> 출처: Clean Code 도서

- 시스템 생성과 시스템 사용을 분리하는 한 가지 방법
- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮김
- 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정함

## 팩토리
<img width="500" src="https://user-images.githubusercontent.com/50200481/205482779-b56908e9-f4f1-4b35-96d5-75a749be6df6.png">

> 출처: Clean Code 도서

- 객체가 생성되는 시점을 애플리케이션에서 결정할 필요도 생김
- LineItem 인스턴스를 생성하여 Order에 추가하는데 Abstract Factory 패턴을 사용함
- 생성 시점은 애플리케이션이 결정하지만 생성하는 코드는 애플리케이션이 모름

## 의존성 주입
- 제어 역전 기법을 의존성 관리에 적용한 매커니즘
- 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘겨 단일 책임 원칙을 지키게 됨
- DI를 사용하더라도 팩토리를 호출하거나 프록시를 생성하는 방법을 통해 초기화 지연을 쓸 수 있도록 제공함

## 확장
- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신임
- 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현하고 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 됨
- 이것이 반복적이고 점진적인 애자일 방식의 핵심임

## 횡단 관심사
> 영속성이란, 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성
- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있음
- 모듈화되고 캡슐화된 방식으로 영속성 방식을 구성할 수 있으나 이렇게 구현한 코드가 온갖 객체로 흩어짐

### AOP (관점 지향 프로그래밍)
- 횡단 관심사를 대처해 모듈성을 확보하는 일반적인 방법론
- 관점(Aspect)이라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"고 명시함

## 자바 프록시
- 개별 객체나 클래스에서 메세드 호출을 감싸는 경우 같이 단순한 상황에 적합한 매커니즘
- JDK에서 제공하는 동적 프록시 인터페이스를 이용함
- 코드 양과 크기가 단점으로 깨끗한 코드를 작성하기는 어려움
- 진정한 AOP 해법에 필요한 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않음

## 순수 자바 AOP 프레임워크
- 대부분의 프록시 코드는 자동화가 가능함
- 순수 자바 관점을 구현하는 여러 자바 프레임워크는 내부적으로 프록시를 사용함
- POJO는 순수하게 도메인에 초점을 맞추며 프레임워크 혹은 다른 도메인에 의존하지 않음
- 따라서 단순하기에 테스트가 쉽고, 올바른 사용자 스토리를 구현하기 쉬움

## AspectJ 관점
- 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ 언어임
- 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장임
- 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하나 새 도구를 사용하여 새 언어 문법과 사용법을 익혀야 함

## 테스트 주도 시스템 아키텍처 구축
- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 테스트 주도 아키텍처 구축이 가능해짐
- 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능함

## 의사 결정을 최적화하라
- 큰 시스템에서는 한 사람이 모든 결정을 내리기 어려움
- 최대한 정보를 모아 최선의 결정을 내리기 위해 가능한 마지막 순간까지 결정을 미루는 방법이 최선임
- 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공함

## 명백한 가치가 있을 때 표준을 현명하게 사용하라
표준을 사용하면,
- 아이디어와 컴포넌트를 재사용하기 쉽움
- 적절한 경험을 가진 사람을 구하기 쉬움
- 좋은 아이디어를 캡슐화하기 쉬움
- 컴포넌트를 엮기 쉬움

## 시스템은 도메인 특화 언어가 필요하다
- DSL은 간단한 스크립트 언어나 표준 언어로 구현한 API
- 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간격을 줄여줌
- DSL을 사용하면, 모든 추상화 수준과 모든 도메인을 POJO로 표현할 수 있음

## 결론
- 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨리기 때문에 시스템은 깨끗해야 함
- POJO를 작성하고 관점 혹은 관점과 유사한 매커니즘을 사용해 각 구현 관심사를 분리하여 모든 추상화 단계에서 의도를 명확히 표현해야 함
- 실제로 돌아가는 가장 단순한 수단을 사용해야 함
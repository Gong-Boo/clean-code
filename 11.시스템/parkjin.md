# 시스템

## 도시를 세운다면?
도시를 혼자서 직접 관리하는 것은 불가능함. 그럼에도 도시가 잘 돌아가는 이유는
- 큰 그림을 그리는 사람뿐만 아니라 작은 사항에 집중하는 사람들
- 개인이 관리하는 구성요소를 효율적으로 돌아가게하는 적절한 추상화와 모듈화

## 시스템 제작과 사용을 분리하라
- **제작**과 **사용**은 매우 다름
- **시작 단계**라는 관심사를 모든 애플리케이션이 풀어야 함

```java

public Service getService() {
  if (service == null)
    service = new MyServiceImpl(...);
    
  return service;
}

```
- 초기화 지연 혹은 계산 지연이라는 기법을 이용해 런타임에서 실제로 필요하기 전까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않음  
- 런타임 로직에서 해당 객체를 전혀 사용하지 않더라도 해당 객체에 대한 의존성이 생김
- 테스트에서도 테스트 전용 객체를 할당해야 하는 문제가 있음

## Main 분리
<img width="500" src="https://user-images.githubusercontent.com/50200481/205482490-cc8e0b74-487d-4b78-a3c0-9949c902243b.png">

> 출처: Clean Code 도서

- 시스템 생성과 시스템 사용을 분리하는 한 가지 방법
- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮김
- 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정함

## 팩토리
<img width="500" src="https://user-images.githubusercontent.com/50200481/205482779-b56908e9-f4f1-4b35-96d5-75a749be6df6.png">

> 출처: Clean Code 도서

- 객체가 생성되는 시점을 애플리케이션에서 결정할 필요도 생김
- LineItem 인스턴스를 생성하여 Order에 추가하는데 Abstract Factory 패턴을 사용함
- 생성 시점은 애플리케이션이 결정하지만 생성하는 코드는 애플리케이션이 모름

## 의존성 주입
- 제어 역전 기법을 의존성 관리에 적용한 매커니즘
- 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘겨 단일 책임 원칙을 지키게 됨
- DI를 사용하더라도 팩토리를 호출하거나 프록시를 생성하는 방법을 통해 초기화 지연을 쓸 수 있도록 제공함

## 확장
- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신임
- 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현하고 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 됨
- 이것이 반복적이고 점진적인 애자일 방식의 핵심임

## 횡단 관심사
> 영속성이란, 데이터를 생성한 프로그램이 종료되어도 사라지지 않는 데이터의 특성
- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있음
- 모듈화되고 캡슐화된 방식으로 영속성 방식을 구성할 수 있으나 이렇게 구현한 코드가 온갖 객체로 흩어짐

### AOP
- 횡단 관심사를 대처해 모듈성을 확보하는 일반적인 방법론
- 관점(Aspect)라는 모듈 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"고 명시함

## 자바 프록시
- 개별 객체나 클래스에서 메세드 호출을 감싸는 경우 같이 단순한 상황에 적합한 매커니즘
- JDK에서 제공하는 동적 프록시 인터페이스를 이용함
- 코드 양과 크기가 단점으로 깨끗한 코드를 작성하기는 어려움
- 진정한 AOP 해법에 필요한 시스템 단위로 실행 지점을 명시하는 메커니즘을 제공하지 않음


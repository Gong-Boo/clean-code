# 단위 테스트

## TDD 법칙 세 가지
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다

위 방식대로 일하면 실제 코드를 전부 테스트하는 테스트 케이스가 나옴
그러나 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발함

## 깨끗한 테스트 코드 유지하기
- 지저분한 테스트 코드를 내놓는 것은 테스트를 안하는 것보다 못함
- 실제 코드가 변화하면 테스트 코드도 변해야 하기 때문에 테스트 코드가 복잡할 수록 실제 코드를 짜는 것보다 오래 걸리기 십상임
- 새버전을 출시할 때마다 유지 보수 비용이 증가하고 결국 테스트 케이스를 폐기하는 상황도 발생함
- 테스트 코드는 실제 코드 못지 않게 중요하며 사고와 설계와 주의를 하여 깨끗하게 작성해야 함

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다
- 코드의 유연성, 유지보수성, 재사용성을 제공하는 버팀목은 단위 테스트임
- 설계를 아무리 잘 나눴더라도 테스트 케이스가 없는 모든 변경은 잠정적인 버그임
- 테스트 케이스가 있다면 코드 변경이 쉽고, 공포가 줄어듬

## 깨끗한 테스트 코드
- 깨끗한 테스트 코드에는 가독성이 필요함
- 정말 필요한 자료 유형과 함수만 사용하여 작성하도록 해야함

## 도메인에 특화된 테스트 언어
- 도메인에 특화된 언어 DSL
- 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 해당 함수와 유틸리티를 사용하면 짜기도 읽기도 쉬워짐
- 이렇게 구현하면, 테스트를 구현하는 당사자와 추후 테스트를 읽어볼 독자를 도와주는 특수 API인 테스트 언어가 됨
- 처음부터 설계된 게 아닌 코드를 계속 리팩토링하며 진화된 API임

## 이중 표현
- 테스트 코드는 실제 환경이 아닌 테스트 환경에서 돌아가는 코드이기에 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없음
- 실제 환경은 컴퓨터 자원과 메모리가 제한적일 가능성이 높으나 테스트 환경은 제한적일 가능성이 낮기에 코드의 깨끗함과는 철저히 무관함

## 테스트 당 assert 하나
- assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠름
- assert문을 병합하는 방식이 불합리하다면, 테스트를 두 개로 쪼개 각자가 assert를 수행하면 됨
- 중복되는 코드가 많아질 경우엔, TEMPLATE METHOD 패턴을 사용하여 중복을 제거 가능함

## 테스트 당 개념 하나
- 개념 당 assert문 수를 최소로 줄여라
- 테스트 함수 하나는 개념 하나만 테스트하라

## F.I.R.S.T
- Fast 빠르게
  - 테스트는 빨리야 함
  - 빠르지 않다면, 자주 돌릴 수 없으며 문제를 찾아내 고치지 못하고 결국 코드 품질이 망가짐
- Independent 독립적으로
  - 테스트는 서로 의존하면 안됨
  - 각 테스트는 독립적으로 어떤 순서로 실행해도 괜찮아야 함
  - 의존할 경우, 실패할 때 나머지도 잇달아 실패하여 원인 및 결함을 찾기 어려워짐
- Repeatable 반복가능하게
  - 테스트는 어떤 환경에서도 가능해야 함
- Self-Validating 자가검증하는 
  -  테스트는 Bool 값으로 결과를 내야함
  -  통과 여부를 알기 위해 로그를 읽게 만들어선 안됨
  -  성공 혹은 실패를 가늠하지 않는다면 판단은 주관적이며 지루한 수작업 평가가 필요하게 됨
- Timely 적시에
  - 테스트는 적시에 작성해야 함
  - 테스트하기 어렵거나 테스트가 불가능하게 설계할 수도 있기에 실제 코드를 구현하기 직전에 구현해야 함

## 결론
- 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화함
- 따라서 지속적으로 표현력을 높이고 간결하며 깨끗하게 관리해야 함
- 테스트 코드를 짜기 쉽도록 테스트 API를 구현하여 DSL을 만들보도록
- 테스트 코드가 방치되어 망가지면 실제 코드도 망가지므로 깨끗하게 유지하여야 함

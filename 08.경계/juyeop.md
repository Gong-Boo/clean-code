## 경계
- 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다.
- 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다.

### 1. 외부 코드 사용하기
- 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다.
- 사용자는 자신의 요구에 집중하는 인터페이스를 바란다.

before: 명시적 형 변환
``` kotlin
val sensors = hashMapOf()
val sensor = sensors.get(id) as Sensor
```

before: 제네릭 활용
``` kotlin
val sensors = hashMapOf<Sensor>()
val sensor = sensors.get(id)
```
- Map 인터페이스가 변할 경우, 수정할 코드가 상당히 많아진다.

after: 클래스 내부에 숨기기
``` kotlin
class Sensor {
    val sensors = hashMapOf()

    fun getById(id: String): Sensor {
        return sensors.get(id) as Sensor
    }
}
```
- 제네릭을 사용하지 않아도 되고, 명시적 형 변환도 클래스 내부에서 한번만 하면 되므로 Map 인터페이스가 변하더라도 프로그램에 영향이 적어진다.
- Sensor 클래스에서 Map을 관리하고 있으므로 해당 클래스에서 정의한 Map 인터페이스만 사용할 수 있다.
- Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.
- Map 인스턴스를 공개 API의 인수로 넘기거나 반환 값으로 사용하지 않는다.

### 2. 경계 살피고 익히기
- 외부 패키지 테스트가 우리 책임은 아니다.
- 하지만 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.
- 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것을 학습 테스트라 부른다.
- 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다.

### 3. log4j 익히기

### 4. 학습 테스트는 공짜 이상이다
- 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
- 패키지 새 버전이 나올 때마다 새로운 위험이 생긴다.
- 새 버전이 우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 밝혀낸다.
- 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기가 쉬워진다, 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠진다.

### 5. 아직 존재하지 않는 코드를 사용하기
- 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.
- 모르는 코드는 아는 코드부터 먼저 작성한 후 추후에 구상한다.

### 6. 깨끗한 경계
- 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.
- 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.
- 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
- 어느 방법이든 코드 가독성이 높아지며 경계 인터페이스를 사용하는 일관성도 높아지며 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

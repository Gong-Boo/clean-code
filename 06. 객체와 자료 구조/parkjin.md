# 객체와 자료 구조
> Clean Code Chapter 06.


## 자료 추상화
| 직교좌표계 | 극좌표계 |
| --- | --- |
| <img width="150" src="https://user-images.githubusercontent.com/50200481/201666113-4d8d688a-0e5b-4587-9bee-801b477b3d28.png"> | <img width="150" src="https://user-images.githubusercontent.com/50200481/201665657-193c3ce7-2114-4319-9015-cb55643be281.png"> |

<img width="350" src="https://user-images.githubusercontent.com/50200481/201663471-fea7b477-72b4-4331-b3a2-3f4c0e76c8c0.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-1: 구현을 외부에 노출
  - 확실히 직교좌표를 사용함
  - 개별적으로 좌표값을 읽고 설정하게 강제함
  - private로 선언하고 get/set 함수를 제공하는 것보다 추상 인터페이스를 제공하여 사용자가 구현을 모른 채 조작할 수 있어야 진정한 클래스임
  
- 목록 6-2: 구현을 완전히 숨김
  - 직교좌표인지 극좌표지인 알 수 없으나 자료구조를 명백히 표현 
  - 메세드가 접급 정책을 강제 하여, 좌표를 읽을 때 각 값을 개별적으로 읽어여 하나, 설정할 때는 한꺼번에 설정함

#

<img width="350" src="https://user-images.githubusercontent.com/50200481/201668050-523c1a91-8768-4238-8f2f-f609b49f90fd.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-3: 구체적인 개념
  - 자동차 연료 상태를 구체적인 숫자 값을 알려줌 

- 목록 6-4: 추상적인 개념
  - 자동차 연료 상태를 백분율이라는 추상적인 개념으로 알려줌

#


#### 정리

- 자료를 세세하게 공개하기보다는 **추상적인 개념으로 표현**하도록
- **인터페이스나 get/set 함수만으로는 추상화가 이뤄지지 않음**

---

## 자료/객체 비대칭

- 객체: **추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개**
- 자료 구조: **자료를 그대로 공개하며 별다른 함수를 제공하지 않음**

<img width="500" src="https://user-images.githubusercontent.com/50200481/201671312-03361dd7-960b-40b8-9949-0a2ae9cda2b2.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-5: 절차적인 클래스
  - ```Square```, ```Rectangle```, ```Circle``` 각 도형 클래스는 간단한 **자료구조이므로 아무 메서드도 제공하지 않음**
  - 도형이 동작하는 방식을 구현한 ```Geometry``` 클래스에 새로운 함수를 추가하더라도 도형 클래스는 아무 영향도 받지 않음
  - 번대로 새 도형 클래스를 추가한다면, ```Geometry``` 클래스의 모든 함수를 고쳐야 함

<img width="400" src="https://user-images.githubusercontent.com/50200481/201673405-37a44d7a-febd-4098-b551-a934bc1b6ef3.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-6: 객체지향적인 클래스
  - 새 도형 클래스를 추가해도 기존 함수에는 아무런 영향이 없음
  - 반면 새 함수를 추가하고 싶다면, 도형 클래스 전부를 고쳐야 함

#

#### 정리

절차지향적인 코드와 객체지향적인 코드는 상호 보완적인 특성이 있음
- 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 **새 함수를 추가하기 쉬우나, 새로운 자료구조를 추가하기 어려움**
- 객체지향 코드는 기존 함수를 변경하지 않으면서 **새 클래스를 추가하기 쉬우나, 새로운 함수를 추가하기 어려움**

새로운 타입이 필요한 경우엔 클래스와 객체지향 기법을 활용, 새로운 함수가 필요한 경우엔 절차적인 코드와 자료구조를 활용

---

## 디미터 법칙

디미터 법칙은 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속을 몰라야한다는 법칙    
객체는 자료를 숨기고 함수를 공개하듯이 **내부구조를 공개하면 안된다는 의미**

> 휴리스틱이란 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나,     
> 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법  

```java

class C {

  Object instanceVariable;

  Object f(Object param) {
    ...
  }

}
```

디미터 법칙은 다음과 같은 객체의 메서드만 호출해야 한다고 주장함

- 클래스 C
- 메서드 f가 생성한 객체
- 메서드 f 인수로 넘어온 객체
- C 클래스의 인스턴스 변수에 저장된 객체


```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
허용된 메서드가 반환하는 객체의 메서드는 호출하면 안되며, 위 코드는 디미터 법칙을 어김

#

### 기차 충돌
위와 같은 코드가 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문에 **기차 충돌**이라 부름    
조잡하다 여겨지는 방식이므로 아래 코드와 같이 나누는 편이 좋음

```java
Options opts = ctxt.getOptions();
File scratchDir = opts .getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

그러나 위 코드도 ```ctxt```, ```opts```, ```scratchDir```이 객체인지 자료구조인지에 따라 디미터 법칙을 위반 여부가 달려 있음   
객체라면 내부를 숨겨야 하므로 디미터 법칙을 위반하지만, 자료구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않음

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```
자료 구조는 무조건 함수 없이 공개 변수만 포함하고, 객체는 비공개 변수와 공개 함수만 포함한다면 간단하겠지만,   
자료구조에도 get/set 함수를 정의하라는 프레임워크와 표준이 존재함

#

### 잡종 구조
**절반은 객체, 절반은 자료구조**인 잡종 구조 
- 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 get/set 함수도 있으며, 공개 함수는 비공개 변수를 그대로 노출함   
- 새로운 함수, 자료구조도 추가하기 어려운 구조로 양쪽의 단점만 모아놓음   
- 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과함   

#

### 구조체 감추기 
위의 ```ctxt```, ```opts```, ```scratchDir```이 진짜 객체라면 내부 구조를 감춰야하므로 앞선 예제 코드처럼 줄줄이 엮어서는 안됨   

디렉토리의 절대경로는 어떻게 얻어야 하나?

1. 공개 메서드가 너무 많아짐
```java
ctxt.getAbsolutePathOfScratchDirectoryOption();
```

2. 메서드가 객체가 아닌 자료구조를 반환한다고 가정해야 함
```java
ctxt.getScratchDirectoryOption().getAbsolutePath();
```

절대 경로가 필요한 이유는 임시파일을 생성하기 위함이라는 것을 알고 있으므로   
```ctxt``` 객체에 임시 파일을 생성하라는 메서드를 제공하여 내부구조를 드러내지 않으며,    
해당 함수는 자신이 몰라도 되는 여러 객체를 탐색할 필요가 없기에 디미터 법칙을 위반하지 않음   

---

## 자료 전달 객체
<img width="450" src="https://user-images.githubusercontent.com/50200481/201708273-dd4651a3-56ca-4474-a9a2-ab0fab78e532.png">

> 코드 이미지 출처: Clean Code 도서

- 공개 변수만 있고, 함수가 없는 클래스가 자료구조의 전형적인 형태로 DTO(자료 전달 객체)라고 함
- 일반적인 형태로는 Bean 구조로 비공개 변수를, get/set 함수로 조작함
- 일부 순수주의자나 만족시킬 뿐 별다른 이익을 제공하지 않음

#

### 활성 레코드
- DTO의 특수한 형태로 일반적인 자료 구조에 save 혹은 find 같은 탐색 함수도 제공함
- 활성 레코드에 비즈니스 규칙 메서드를 추가해 자료 구조를 객체로 취급하는 것은 바람직하지 않음   
- 이로 인해 자료구조도 아니고 객체도 아닌 잡종 구조가 나옴
- 해결 방안으로는 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체를 따로 생성하는 것

---

## 결론
| 객체 | 자료구조 |
| --- | --- |
| 함수를 공개하고 변수를 숨김 |  별다른 함수 없이 변수룰 노출함 |
| 기존 함수를 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 함수를 추가하는 것은 어려움 | 기존 자료구조에 새 함수를 추가하기는 쉬우나, 기존 함수에 새 자료구조를 추가하기는 어려움 |

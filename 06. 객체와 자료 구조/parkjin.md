# 객체와 자료 구조
> Clean Code Chapter 06.


## 자료 추상화
| 직교좌표계 | 극좌표계 |
| --- | --- |
| <img width="150" src="https://user-images.githubusercontent.com/50200481/201666113-4d8d688a-0e5b-4587-9bee-801b477b3d28.png"> | <img width="150" src="https://user-images.githubusercontent.com/50200481/201665657-193c3ce7-2114-4319-9015-cb55643be281.png"> |

<img width="350" src="https://user-images.githubusercontent.com/50200481/201663471-fea7b477-72b4-4331-b3a2-3f4c0e76c8c0.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-1: 구현을 외부에 노출
  - 확실히 직교좌표를 사용함
  - 개별적으로 좌표값을 읽고 설정하게 강제함
  - private로 선언하고 set, get 함수를 제공하는 것보다 추상 인터페이스를 제공하여 사용자가 구현을 모른 채 조작할 수 있어야 진정한 클래스임
  
- 목록 6-2: 구현을 완전히 숨김
  - 직교좌표인지 극좌표지인 알 수 없으나 자료구조를 명백히 표현 
  - 메세드가 접급 정책을 강제 하여, 좌표를 읽을 때 각 값을 개별적으로 읽어여 하나, 설정할 때는 한꺼번에 설정함

#

<img width="350" src="https://user-images.githubusercontent.com/50200481/201668050-523c1a91-8768-4238-8f2f-f609b49f90fd.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-3: 구체적인 개념
  - 자동차 연료 상태를 구체적인 숫자 값을 알려줌 

- 목록 6-4: 추상적인 개념
  - 자동차 연료 상태를 백분율이라는 추상적인 개념으로 알려줌

#


#### 결론

- 자료를 세세하게 공개하기보다는 **추상적인 개념으로 표현**하도록
- **인터페이스나 set, get 함수만으로는 추상화가 이뤄지지 않음**

---

## 자료/객체 비대칭

- 객체: **추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개**
- 저료 구조: **자료를 그대로 공개하며 별다른 함수를 제공하지 않음**

<img width="500" src="https://user-images.githubusercontent.com/50200481/201671312-03361dd7-960b-40b8-9949-0a2ae9cda2b2.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-5: 절차적인 클래스
  - ```Square```, ```Rectangle```, ```Circle``` 각 도형 클래스는 간단한 **자료구조이므로 아무 메서드도 제공하지 않음**
  - 도형이 동작하는 방식을 구현한 ```Geometry``` 클래스에 새로운 함수를 추가하더라도 도형 클래스는 아무 영향도 받지 않음
  - 번대로 새 도형 클래스를 추가한다면, ```Geometry``` 클래스의 모든 함수를 고쳐야 함

<img width="400" src="https://user-images.githubusercontent.com/50200481/201673405-37a44d7a-febd-4098-b551-a934bc1b6ef3.png">

> 코드 이미지 출처: Clean Code 도서

- 목록 6-6: 객체지향적인 클래스
  - 새 도형 클래스를 추가해도 기존 함수에는 아무런 영향이 없음
  - 반면 새 함수를 추가하고 싶다면, 도형 클래스 전부를 고쳐야 함

#

#### 결론

절차지향적인 코드와 객체지향적인 코드는 상호 보완적인 특성이 있음
- 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 **새 함수를 추가하기 쉬우나, 새로운 자료구조를 추가하기 어려움**
- 객체지향 코드는 기존 함수를 변경하지 않으면서 **새 클래스를 추가하기 쉬우나, 새로운 함수를 추가하기 어려움**

새로운 타입이 필요한 경우엔 클래스와 객체지향 기법을 활용, 새로운 함수가 필요한 경우엔 절차적인 코드와 자료구조를 활용

---

## 디미터 법칙

디미터 법칙은 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속을 몰라야한다는 법칙    
객체는 자료를 숨기고 함수를 공개하듯이 **내부구조를 공개하면 안된다는 의미**

> 휴리스틱이란 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나,     
> 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법  

```java

class C {

  Object instanceVariable;

  Object f(Object param) {
    ...
  }

}
```

디미터 법칙은 다음과 같은 객체의 메서드만 호출해야 한다고 주장함

- 클래스 C
- 메서드 f가 생성한 객체
- 메서드 f 인수로 넘어온 객체
- C 클래스의 인스턴스 변수에 저장된 객체


```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
허용된 메서드가 반환하는 객체의 메서드는 호출하면 안되며, 위 코드는 디미터 법칙을 어김

#

### 기차 충돌
위와 같은 코드가 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문에 **기차 충돌**이라 부름    
조잡하다 여겨지는 방식이므로 아래 코드와 같이 나누는 편이 좋음

```java
Options opts = ctxt.getOptions();
File scratchDir = opts .getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```

그러나 위 코드도 ```ctxt```, ```opts```, ```scratchDir```이 객체인지 자료구조인지에 따라 디미터 법칙을 위반 여부가 달려 있음   
객체라면 내부를 숨겨야 하므로 디미터 법칙을 위반하지만, 자료구조라면 내부 구조를 노출하므로 디미터 법칙이 적용되지 않음

```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```
자료 구조는 무조건 함수 없이 공개 변수만 포함하고, 객체는 비공개 변수와 공개 함수만 포함한다면 간단하겠지만,   
자료구조에도 get, set 함수를 정의하라는 프레임워크와 표준이 존재함

#

### 잡종 구조
가끔 절반은 객체, 절반은 자료구조인 잡종 구조가 나옴

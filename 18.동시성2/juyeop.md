## 동시성2

### 클라이언트/서버 예제
#### 1. 서버
- 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다.
- 클라이언트는 소켓에 연결해 요청을 보낸다.
- 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다.
- I/O
  + 소켓 사용
  + 데이터베이스 연결
  + 가상 메모리 스와핑 기다리기

- 프로세서
  + 수치 계산
  + 정규 표현식 처리
  + 가비지 컬렉션

- 특정 연산을 살펴보면 대개 하나가 지배적이다.
- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
- 반면 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.

#### 2. 스레드 추가하기
- 단일 스레드에서 다중 스레드로 코드를 수정하니 테스트에 통과했다.

#### 3. 서버 살펴보기
- 코드에서 한계를 명시하지 않으면 이론상으로는 JVM이 허용하는 수까지 스레드를 만든다.
- 하지만 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 동작을 멈출지도 모른다.
  + 주엽 생각: 처음에 과도하게 스레드를 만들어서 더 이상의 스레드를 만들 수 없어서 그런거 아닐까?
  + 다른 분들의 의견은?

- 서버 코드가 지는 책임
  + 소켓 연결 관리
  + 클라이언트 처리
  + 스레드 정책
  + 서버 종료 정책

- 단일 책임 원칙을 위반한다.
- 스레드를 관리하는 코드는 스레드만 관리해야 한다.

#### 4. 결론
- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켰다.
- 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

### 가능한 실행 경로
- 스레드 하나가 IdGenerator 인스턴스 하나를 사용한다고 가정하면 실행 경로와 가능한 결과는 단 하나다.
- 스레드 2개가 IdGenerator 인스턴스 하나를 사용한다면 3가지 결과가 나올 수 있다.
  + A 스레드 94 / B 스레드 95
  + A 스레드 95 / B 스레드 94
  + A 스레드 94 / B 스레드 94
  + 가능한 실행 경로 수와 JVM의 동작 방식을 알아야 한다.

#### 1. 경로 수
- return ++lastIdUsed라는 자바 코드 한 줄은 바이트 코드 명령 8개에 해당한다.
- 두 스레드가 명령 8개를 뒤섞어 실행할 가능성이 충분하다.
- 경우의 수 공식 (NT)! / N!^2
- 루프나 분기가 없는 명령 N개를 스레드 T개로 차례로 실행한다면 가능한 경로 수는 다음과 같다.
  + Ex) 명령 8개, 스레드 2개 -> 경우의 수는 12,870개

- 위 상황에서 synchronized를 붙이면 가능한 경로 수가 2개로 줄어든다.
- 스레드가 N개라면 가능한 경로 수는 N!이다.

#### 2. 심층 분석
- 중단이 불가능한 연산을 원자적 연산으로 정의한다.
- 자바 메모리 모델에 의하면 32비트(4바이트) 메모리에 값을 할당하는 연산은 중단이 불가능하기 때문이다.
- JVM 명세에 따르면 64비트 값을 할당하는 연산은 32비트 값을 할당하는 연산 두 개로 나눠진다.
- 그러니까 첫 32비트 값을 할당한 직후에 그리고 둘째 32비트 값을 할당하기 직전에 다른 스레드가 끼어들어 두 32비트 값 중 하나를 변경할 수 있다는 의미다.
  + 어떤 프로세서는 원자적 연산으로 처리할지도 모른다.

- 전처리 증가 연산자는 원자적 연산이 아니다.
- 프레임
  + 모든 메서드 호출에는 프레임이 필요하다.
  + 반환 주소, 매개변수, 지역 변수를 포함한다.
  + 호출 스택을 정의할 때 사용하는 표준 기법이다.

- 지역변수
  + 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수를 갖는다.

- 피연산자 스택
  + JVM이 지원하는 명령 대다수는 매개변수를 받는다.
  + 이런 매개변수를 저장하는 장소다.
  + LIFO 자료구조다.

- ALOAD, ICONST, PUTFIELD 명령 세 개는 확실히 원자적이다.
- 연산자는 메서드 범위에 속한 정보만 다루므로 다른 스레드로부터 간섭 받지 않는다.
- 스레드 10개가 모두 상수 값을 할당하기 때문에 스레드가 서로 간섭을 하더라도 최종 결과는 마찬가지다.
- 그러나 getNexId 메서드에서 ++ 연산은 문제를 일으킨다.
  + 과정은 책의 예시를 참고바람

#### 3. 결론
- 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.
- 전처리, 후처리 상관없이 ++ 연산은 분명히 원자적 연산이 아니다.
- 아래 3가지를 알아야 한다.
  + 공유 객체/값이 있는 곳
  + 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
  + 동시성 문제를 방지하는 방법












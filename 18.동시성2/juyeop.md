## 동시성2

### 클라이언트/서버 예제
#### 1. 서버
- 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다.
- 클라이언트는 소켓에 연결해 요청을 보낸다.
- 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다.
- I/O
  + 소켓 사용
  + 데이터베이스 연결
  + 가상 메모리 스와핑 기다리기

- 프로세서
  + 수치 계산
  + 정규 표현식 처리
  + 가비지 컬렉션

- 특정 연산을 살펴보면 대개 하나가 지배적이다.
- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
- 반면 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.

#### 2. 스레드 추가하기
- 단일 스레드에서 다중 스레드로 코드를 수정하니 테스트에 통과했다.

#### 3. 서버 살펴보기
- 코드에서 한계를 명시하지 않으면 이론상으로는 JVM이 허용하는 수까지 스레드를 만든다.
- 하지만 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 동작을 멈출지도 모른다.
  + 주엽 생각: 처음에 과도하게 스레드를 만들어서 더 이상의 스레드를 만들 수 없어서 그런거 아닐까?
  + 다른 분들의 의견은?

- 서버 코드가 지는 책임
  + 소켓 연결 관리
  + 클라이언트 처리
  + 스레드 정책
  + 서버 종료 정책

- 단일 책임 원칙을 위반한다.
- 스레드를 관리하는 코드는 스레드만 관리해야 한다.

#### 4. 결론
- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켰다.
- 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

### 가능한 실행 경로
- 스레드 하나가 IdGenerator 인스턴스 하나를 사용한다고 가정하면 실행 경로와 가능한 결과는 단 하나다.
- 스레드 2개가 IdGenerator 인스턴스 하나를 사용한다면 3가지 결과가 나올 수 있다.
  + A 스레드 94 / B 스레드 95
  + A 스레드 95 / B 스레드 94
  + A 스레드 94 / B 스레드 94
  + 가능한 실행 경로 수와 JVM의 동작 방식을 알아야 한다.

#### 1. 경로 수
- return ++lastIdUsed라는 자바 코드 한 줄은 바이트 코드 명령 8개에 해당한다.
- 두 스레드가 명령 8개를 뒤섞어 실행할 가능성이 충분하다.
- 경우의 수 공식 (NT)! / N!^2
- 루프나 분기가 없는 명령 N개를 스레드 T개로 차례로 실행한다면 가능한 경로 수는 다음과 같다.
  + Ex) 명령 8개, 스레드 2개 -> 경우의 수는 12,870개

- 위 상황에서 synchronized를 붙이면 가능한 경로 수가 2개로 줄어든다.
- 스레드가 N개라면 가능한 경로 수는 N!이다.

#### 2. 심층 분석
- 중단이 불가능한 연산을 원자적 연산으로 정의한다.
- 자바 메모리 모델에 의하면 32비트(4바이트) 메모리에 값을 할당하는 연산은 중단이 불가능하기 때문이다.
- JVM 명세에 따르면 64비트 값을 할당하는 연산은 32비트 값을 할당하는 연산 두 개로 나눠진다.
- 그러니까 첫 32비트 값을 할당한 직후에 그리고 둘째 32비트 값을 할당하기 직전에 다른 스레드가 끼어들어 두 32비트 값 중 하나를 변경할 수 있다는 의미다.
  + 어떤 프로세서는 원자적 연산으로 처리할지도 모른다.

- 전처리 증가 연산자는 원자적 연산이 아니다.
- 프레임
  + 모든 메서드 호출에는 프레임이 필요하다.
  + 반환 주소, 매개변수, 지역 변수를 포함한다.
  + 호출 스택을 정의할 때 사용하는 표준 기법이다.

- 지역변수
  + 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역 변수를 갖는다.

- 피연산자 스택
  + JVM이 지원하는 명령 대다수는 매개변수를 받는다.
  + 이런 매개변수를 저장하는 장소다.
  + LIFO 자료구조다.

- ALOAD, ICONST, PUTFIELD 명령 세 개는 확실히 원자적이다.
- 연산자는 메서드 범위에 속한 정보만 다루므로 다른 스레드로부터 간섭 받지 않는다.
- 스레드 10개가 모두 상수 값을 할당하기 때문에 스레드가 서로 간섭을 하더라도 최종 결과는 마찬가지다.
- 그러나 getNexId 메서드에서 ++ 연산은 문제를 일으킨다.
  + 과정은 책의 예시를 참고바람

#### 3. 결론
- 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.
- 전처리, 후처리 상관없이 ++ 연산은 분명히 원자적 연산이 아니다.
- 아래 3가지를 알아야 한다.
  + 공유 객체/값이 있는 곳
  + 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
  + 동시성 문제를 방지하는 방법

### 라이브러리를 이해하라
#### 1. Executor 프레임워크
- Executor 프레임워크는 스레드 풀링으로 정교한 실행을 지원한다.
- 애플리케이션에서 스레드는 생성하나 스레드 풀을 사용하지 않는다면 혹은 직접 생성한 스레드 풀을 사용한다면 Executor 클래스를 고려하기 바란다.
- Callable 인터페이스는 Runnable 인터페이스와 유사하지만 결과 값을 반환한다.
- Future는 독립적인 연산 여럿을 실행한 후 모두가 끝나기를 기다릴 때 유용하다.

#### 2. 스레드를 차단하지 않는 방법
- 최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신한다.
- 현대 프로세서는 흔히 CAS(Compare and Swap)라 불리는 연산을 지원한다.
  + CAS 연산은 원자적이다.
- synchronized 키워드는 언제나 락을 건다.
- 락을 거는 대가는 여전히 비싸다.
- 스레드 몇 개가 아니 많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적이다.
- 메서드가 공유 변수를 갱신하려 든다면 CAS 연산은 현재 변수 값이 최종으로 알려진 값인지 확인한다.
- 아니라면 다른 스레드가 끼어들었다는 뜻이므로 변수 값을 갱신하지 않는다.

#### 3. 다중 스레드 환경에서 안전하지 않은 클래스
- 종류
  + SimpleDateFormat
  + 데이터베이스 연결
  + java.util 컨테이너 클래스
  + 서블릿

- 몇몇 집합 클래스는 스레드에 안전한 메서드를 제공한다.
- 하지만 그런 메서드 여럿을 호출하는 작업은 스레드에 안전하지 않다.
- 해결하는 방법이 몇가지 있다.
  + HashTable 잠그기
  + ADAPTER 패턴을 사용해서 HashTable을 객체로 감싼 후 다른 API를 사용한다.
  + 스레드에 안전한 집합 클래스를 사용한다.
    * java.util.concurrent 패키지가 제공하는 집한 클래스는 putIfAbsent() 등과 같이 스레드에 안전한 메서드를 제공한다.

### 메서드 사이에 존재하는 의존성을 조심하라
- 정수 목록 끝에서 스레드가 서로 간섭할 때만 문제가 발생하기 때문이다.

#### 1. 실패를 용인하다
- 위에서 클라이언트가 예외를 받아 처리해도 되겠다.

#### 2. 클라언트-기반 잠금
- 각 클라이언트는 synchronized 키워드를 이용해 IntegerIterator 객체에 락을 건다.
- 다만, DRY(Don't Repeat Yourself) 원칙을 위반한다.
- 엉클밥 아재의 이전 추억에 대한 TMI가 이어짐
  + 결론: 클라이언트-기반 잠금 매커니즘은 진짜 사람이 할 짓이 아니다.

#### 3. 서버-기반 잠금
- 여기서는 실제로 다중 스레드를 고려하게 클래스 API를 변경했다.
- 일반적으로 서버-기반 잠금이 더 바람직하다.
- 코드 중복이 줄어든다.
- 성능이 좋아진다.
  + 단일스레드 환경으로 시스템을 배치할 경우 서버만 교체하면 되므로 오버헤드가 줄어든다.

- 오류가 발생할 가능성이 줄어든다.
- 스레드 정책이 하나다.
- 공유 변수 범위가 줄어든다.
  + 클라이언트가 공유 변수 자체를 모르거나 공유변수가 잠긴 방식을 몰라도 된다.

- 만약 서버 코드에 손을 대지 못핮다면 ADAPTER 패턴을 사용해서 API를 변경한 후 잠금을 추가한다.
- 또는 스레드에 안전하며 인터체이스가 확장된 집합 클래스를 사용한다.











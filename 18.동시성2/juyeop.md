## 동시성2
### 클라이언트/서버 예제

### 1. 서버
- 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다.
- 클라이언트는 소켓에 연결해 요청을 보낸다.
- 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다.
- I/O
  + 소켓 사용
  + 데이터베이스 연결
  + 가상 메모리 스와핑 기다리기

- 프로세서
  + 수치 계산
  + 정규 표현식 처리
  + 가비지 컬렉션

- 특정 연산을 살펴보면 대개 하나가 지배적이다.
- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
- 반면 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.

### 2. 스레드 추가하기
- 단일 스레드에서 다중 스레드로 코드를 수정하니 테스트에 통과했다.

### 3. 서버 살펴보기
- 코드에서 한계를 명시하지 않으면 이론상으로는 JVM이 허용하는 수까지 스레드를 만든다.
- 하지만 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 동작을 멈출지도 모른다.
  + 주엽 생각: 처음에 과도하게 스레드를 만들어서 더 이상의 스레드를 만들 수 없어서 그런거 아닐까?
  + 다른 분들의 의견은?

- 서버 코드가 지는 책임
  + 소켓 연결 관리
  + 클라이언트 처리
  + 스레드 정책
  + 서버 종료 정책

- 단일 책임 원칙을 위반한다.
- 스레드를 관리하는 코드는 스레드만 관리해야 한다.

### 4. 결론
- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켰다.
- 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.






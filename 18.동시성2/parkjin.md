# 동시성 II

## 클라이언트/서버 예제

### 서버
클라이언트/서버 소켓 애플리케이션의 **성능이 만족스럽지 않을 때**   
이벤트 폴링 루프를 구현하면 모를까, 단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다

먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다
- **I/O**: 소켓 사용, 데이터 베이스 연결, 가상 메모리 스와핑 기다리기 등
- **프로세서**: 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

만약 주로 **프로세서 연산에 시간을 보낸다면**    
CPU 사이클은 한계가 있기 때문에 스레드를 늘인다고 빨라지지 않아 **새로운 하드웨어를 추가해 성능을 높이는 방법**이 적합하다

반면 주로 **I/O 연산에 시간을 보낸다면**     
시스템 한쪽이 I/O를 기다리는 동안 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용하는 **동시성을 통해 성능을 높여주기도 한다**

### 스레드 추가하기
소켓 자료 처리량을 높여 성능을 높이고 싶다면 스레드를 추가한다

### 서버 살펴보기
위 방법대로 고친 서버의 성능은 좋으나 새로운 문제를 일으킨다    
만드는 스레드의 개수를 코드에서 한계를 명시하지 않아 이론상 JVM이 허용하는 수까지 가능하기 때문에 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 멈출지도 모른다

또한, 깨끗한 코드와 구조라는 관점에서도 문제가 있다
다중 스레드 프로그램을 깨끗하게 유지하려면 동시성 문제를 추적하기 위해 **스레드를 관리하는 코드는 스레드만 관리해야 한다**

소켓 프로그램의 책임인,
- 소켓 연결 관리
- 클라이언트 처리
- 스레드 정택
- 서버 종료 정책    

같은 책임마다 클래스를 만든다면, 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다   
스레드를 걱정하지 않고서 다른 책임을 테스트하기가 훨씬 더 쉬워진다

### 결론
동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 **단일 책임 원칙**이 특히 중요하다


## 가능한 실행 경로
여러 스레드에서 연산을 실행하였을 때 다양한 결과가 나오는 이유를 알려면 실행 **경로 수**와 **JVM의 동작 방식**을 알아야 한다

### 경로 수
가능한 경로 수를 계산하기 위해 자바 컴파일러가 생성한 바이트 코드를 살펴봐야 한다   
한 줄의 연산 코드는 바이트 코드 명령 8개에 해당한다고 했을 때 여러 스레드에서 명령 8개를 뒤섞어 실행할 가능성이 충분하다   

루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로의 수는 다음과 같다  
```(NT)! / N^T```

### 심층 분석
중단이 불가능한 연산을 **원자적 연산**으로 정의한다
전처리 연산자는 중단이 가능하기 때문에 원자적 연산이 아니다

바이트 코드를 보기 전에 다음 정의 세 개를 명심해야 한다   
- 프레임
  - 모든 메서드 호출에는 프레임이 필요하다
  - 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수를 포함한다
  - 프레임은 호출 스택을 정의할 때 사용하는 표준 기법이다
  - 현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출을 지원한다

- 지역 변수
  - 메서드 범위 내에 정의되는 모든 변수를 가리킨다
  - 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역변수를 갖는다
  - this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다

- 피연산자 스택
  - JVM이 지원하는 명령 대다수는 매개변수를 받는다
  - 피연산자 스택은 이런 매개변수를 저장하는 장소다
  - 피연산자 스택은 LIFO(last in, first out) 자료구조다

### 결론
스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해 바이트 코드를 속속들이 이해할 필요는 없으나,   
어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다

즉, 다음을 알아야 한다
- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법


## 라이브러리를 이해하라 

### Executor 프레임워크
```java.util.concurrent``` 패키지에 속하는 클래스로 스레드 풀링으로 정교한 실행을 지원한다   
애플리케이션에서 스레드를 생성하나 스레드 풀을 사용하지 않는다면 혹은 직접 생성한 스레드 풀을 사용한다면 Executor 클래스를 고려해야 한다   
코드가 깔끔해지고, 이해하기 쉬워지고, 크기가 작아진다


### 스레드를 차단하지 않는 (non blocking) 방법 
최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신하며, CAS(Compare and Swap) 연산을 지원한다   

synchronized 키워드는 둘째 스레드가 값을 갱생하지 않더라도 언제나 lock을 건다   
자바 버전이 올라갈 때마다 내장 lock의 성능이 좋아졌지만 lock의 대가는 여전히 비싸다    

스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 잦지 않다는 가정에서 출발한다   
그래서 그런 상황이 발생했는지 효율적으로 감지해 갱신이 성공할 때까지 재차 시도한다   
많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 감지하는 쪽이 거의 항상 더 효율적이다    

### 다중 스레드 환경에서 안전하지 않은 클래스

예로
- SimpleDateFormat
- 데이터베이스 연결
- java.util 컨테이너 클래스
- 서블릿

## 데드락
다음 네 가지 조건을 모두 만족해야 데드락이 발생한다

### 상호 배제
여러 스레드가 한 자원을 공유하나 그 자원은 
- 여러 스레드가 동시에 사용하지 못하며
- 개수가 제한적이라면

상호 배제 조건을 만족한다

### 잠금 & 대기
일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해    
작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다

### 선점 불가
자원을 점유한 스레드가 스스로 내놓지 않는 이상    
한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다    

### 순환 대기
죽음의 포옹이라고도 한다

<img width="300" src="https://user-images.githubusercontent.com/50200481/217022508-4dc94e6b-7dde-414e-bfe5-d28330d6f53e.png">
> 출처: clean code 도서

### 상호 배제 조건 깨기
- 동시에 사용해도 괜찮은 자원을 사용한다 (예, Atomic 클래스)
- 스레드 수 이상으로 자원 수를 늘인다
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다

### 잠금 & 대기 조건 깨기
대기하지 않으면 데드락이 발생하지 않는다
각 자원을 점유하기 전에 확인하여 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다

기아와 라이브락 문제가 있지만, 아무 대책이 없는 경우보다는 좋다.

### 선점 불가 조건 깨기
다른 스레드로부터 자원을 뺏어오는 방법이다
필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라 요청하고, 소유 스레드가 다른 자원을 기다리던 중이었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작한다   

앞의 전략과 비슷하나 스레드가 자원을 기다려도 괜찮다는 이점이 있다   
그러나 모든 요청을 관리하기가 간단하지 않기에 조심해야 한다

### 순환 대기 조건 깨기
모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 순환 대기는 불가능해진다   
그러나 자원의 할당 순서와 사용 순서가 다르거나, 순서에 따라 할당하기 어려운 경우가 발생할 문제가 있다

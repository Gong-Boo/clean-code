# 동시성 II

## 클라이언트/서버 예제

### 서버
클라이언트/서버 소켓 애플리케이션의 **성능이 만족스럽지 않을 때**   
이벤트 폴링 루프를 구현하면 모를까, 단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다

먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다
- **I/O**: 소켓 사용, 데이터 베이스 연결, 가상 메모리 스와핑 기다리기 등
- **프로세서**: 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

만약 주로 **프로세서 연산에 시간을 보낸다면**    
CPU 사이클은 한계가 있기 때문에 스레드를 늘인다고 빨라지지 않아 **새로운 하드웨어를 추가해 성능을 높이는 방법**이 적합하다

반면 주로 **I/O 연산에 시간을 보낸다면**     
시스템 한쪽이 I/O를 기다리는 동안 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용하는 **동시성을 통해 성능을 높여주기도 한다**

### 스레드 추가하기
소켓 자료 처리량을 높여 성능을 높이고 싶다면 스레드를 추가한다

### 서버 살펴보기
위 방법대로 고친 서버의 성능은 좋으나 새로운 문제를 일으킨다    
만드는 스레드의 개수를 코드에서 한계를 명시하지 않아 이론상 JVM이 허용하는 수까지 가능하기 때문에 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 멈출지도 모른다

또한, 깨끗한 코드와 구조라는 관점에서도 문제가 있다
다중 스레드 프로그램을 깨끗하게 유지하려면 동시성 문제를 추적하기 위해 **스레드를 관리하는 코드는 스레드만 관리해야 한다**

소켓 프로그램의 책임인,
- 소켓 연결 관리
- 클라이언트 처리
- 스레드 정택
- 서버 종료 정책    

같은 책임마다 클래스를 만든다면, 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다   
스레드를 걱정하지 않고서 다른 책임을 테스트하기가 훨씬 더 쉬워진다

### 결론
동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 **단일 책임 원칙**이 특히 중요하다


## 가능한 실행 경로
여러 스레드에서 연산을 실행하였을 때 다양한 결과가 나오는 이유를 알려면 실행 **경로 수**와 **JVM의 동작 방식**을 알아야 한다

### 경로 수
가능한 경로 수를 계산하기 위해 자바 컴파일러가 생성한 바이트 코드를 살펴봐야 한다   
한 줄의 연산 코드는 바이트 코드 명령 8개에 해당한다고 했을 때 여러 스레드에서 명령 8개를 뒤섞어 실행할 가능성이 충분하다   

루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로의 수는 다음과 같다  
```(NT)! / N^T```

### 심층 분석
중단이 불가능한 연산을 **원자적 연산**으로 정의한다
전처리 연산자는 중단이 가능하기 때문에 원자적 연산이 아니다

바이트 코드를 보기 전에 다음 정의 세 개를 명심해야 한다   
- 프레임
  - 모든 메서드 호출에는 프레임이 필요하다
  - 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수를 포함한다
  - 프레임은 호출 스택을 정의할 때 사용하는 표준 기법이다
  - 현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출을 지원한다

- 지역 변수
  - 메서드 범위 내에 정의되는 모든 변수를 가리킨다
  - 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역변수를 갖는다
  - this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다

- 피연산자 스택
  - JVM이 지원하는 명령 대다수는 매개변수를 받는다
  - 피연산자 스택은 이런 매개변수를 저장하는 장소다
  - 피연산자 스택은 LIFO(last in, first out) 자료구조다

### 결론
스레드가 서로의 작업을 덮어쓰는 과정을 이해하기 위해 바이트 코드를 속속들이 이해할 필요는 없으나,   
어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다

즉, 다음을 알아야 한다
- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법


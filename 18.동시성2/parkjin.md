# 동시성 II

## 클라이언트/서버 예제

### 서버
클라이언트/서버 소켓 애플리케이션의 **성능이 만족스럽지 않을 때**   
이벤트 폴링 루프를 구현하면 모를까, 단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다

먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다
- **I/O**: 소켓 사용, 데이터 베이스 연결, 가상 메모리 스와핑 기다리기 등
- **프로세서**: 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

만약 주로 **프로세서 연산에 시간을 보낸다면**    
CPU 사이클은 한계가 있기 때문에 스레드를 늘인다고 빨라지지 않아 **새로운 하드웨어를 추가해 성능을 높이는 방법**이 적합하다

반면 주로 **I/O 연산에 시간을 보낸다면**     
시스템 한쪽이 I/O를 기다리는 동안 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용하는 **동시성을 통해 성능을 높여주기도 한다**

### 스레드 추가하기
소켓 자료 처리량을 높여 성능을 높이고 싶다면 스레드를 추가한다

### 서버 살펴보기
위 방법대로 고친 서버의 성능은 좋으나 새로운 문제를 일으킨다    
만드는 스레드의 개수를 코드에서 한계를 명시하지 않아 이론상 JVM이 허용하는 수까지 가능하기 때문에 너무 많은 사용자가 한꺼번에 몰린다면 시스템이 멈출지도 모른다

또한, 깨끗한 코드와 구조라는 관점에서도 문제가 있다
다중 스레드 프로그램을 깨끗하게 유지하려면 동시성 문제를 추적하기 위해 **스레드를 관리하는 코드는 스레드만 관리해야 한다**

소켓 프로그램의 책임인,
- 소켓 연결 관리
- 클라이언트 처리
- 스레드 정택
- 서버 종료 정책    

같은 책임마다 클래스를 만든다면, 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다   
스레드를 걱정하지 않고서 다른 책임을 테스트하기가 훨씬 더 쉬워진다

### 결론
동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 **단일 책임 원칙**이 특히 중요하다


## 가능한 실행 경로
여러 스레드에서 연산을 실행하였을 때 다양한 결과가 나오는 이유를 알려면 실행 **경로 수**와 **JVM의 동작 방식**을 알아야 한다

### 경로 수
가능한 경로 수를 계산하기 위해 자바 컴파일러가 생성한 바이트 코드를 살펴봐야 한다   
한 줄의 연산 코드는 바이트 코드 명령 8개에 해당하기 때문에 여러 스레드에서 명령 8개를 뒤섞어 실행할 가능성이 충분하다   

루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로의 수는 다음과 같다  
```(NT)! / N^T```

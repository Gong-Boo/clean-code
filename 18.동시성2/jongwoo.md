# 동시성2

## 클라이언트/서버 예제

### 서버
- 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다
- 클라이언트는 소켓에 연결해 요청을 보낸다
- 메시지를 처리한 후, 다음 클라이언트 요청을 기다린다
- 서버가 각 클라이언트 요청을 적절한 시간 내에 처리하면 시스템은 테스트를 통과한다
- 만약 테스트가 실패한다면 어플리케이션이 어디서 시간을 보내는지 알아야한다.

- I/O
  - 소켓사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보냄
- 프로세서
  - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보냄

- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
- 반면 프로그램이 주로 I/O연산에 시간을 보낸다면, 동시성이 성능을 높여주기도 한다. 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있다.

### 스레드 추가하기
- 성능 테스트가 실패했을 시, 단일 스레드에서 다중스레드로 변경하니 통과한다.

### 서버 살펴보기
- 새 서버에서 만드는 스레드 수는 코드에서 한계를 명시하지 않으면 이론상으로 JVM이 허용하는 수까지 가능하다.
- 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰릴시 시스템이 동작을 멈출수도 있다.
- 서버 코드가 지는 책임
  - 소켓 연결 관리
  - 클라이언트 처리
  - 스레드 정책
  - 서버 종료 정책

- 불행하게도 이모든 책임은 process가 진다.
- 즉 단일 책임 원칙을 위반한다.

### 결론
- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켰다.
- 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

## 가능한 실행 경로

### 경로 수
- 가능한 경로 수를 계산하기 위해서는 자바 컴파일러가 생성한 바이트 코드를 살펴봐야 한다.
- 루프나 분기가 없는 명령N개를 스레드 T개가 차례로 실행한다면 가능한 경우의 수는 (NT)!/N!^T 과 같다.

### 심층 분석
- 원자적 연산이란, 중단이 불가능한 연산을 원자적 연산으로 정의한다.

- 바이트 코드를 보기 전에 아래 3가지 정의를 명심해야 한다.
  - 프레임
    1. 모든 메서드 호출에는 프레임이 필요하다.
    2. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역변수를 포함한다.
    3. 프레임은 호출 스,택을 정의할 때 사용하는 표준 기법이다.
  
  - 지역 변수
    1. 메서드 범위 내에 정의되는 모든 변수를 가리킨다.
    2. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역변수를 갖는다.
    3. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다.

  - 피연산자 스택
    1. JVM이 지원하는 명령 대다수는 매개변수를 받는다.
    2. 피연산자 스택은 이런 매개변수를 저장하는 장소다.
    3. 피연산자 스택은 표준 LIFO 자료구조다.

### 결론
- 어떤 연산이 안전하고 어떤 연산이 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.
- ++ 연산은 원자적 연산이라 오해하는 경우도 많은데, 아니다.

## 라이브러리를 이해하라

### Executor 프레임워크
- 

# 동시성2

## 클라이언트/서버 예제

### 서버
- 서버는 소켓을 열어놓고 클라이언트가 연결하기를 기다린다
- 클라이언트는 소켓에 연결해 요청을 보낸다
- 메시지를 처리한 후, 다음 클라이언트 요청을 기다린다
- 서버가 각 클라이언트 요청을 적절한 시간 내에 처리하면 시스템은 테스트를 통과한다
- 만약 테스트가 실패한다면 어플리케이션이 어디서 시간을 보내는지 알아야한다.

- I/O
  - 소켓사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보냄
- 프로세서
  - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보냄

- 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.
- 반면 프로그램이 주로 I/O연산에 시간을 보낸다면, 동시성이 성능을 높여주기도 한다. 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있다.

### 스레드 추가하기
- 성능 테스트가 실패했을 시, 단일 스레드에서 다중스레드로 변경하니 통과한다.

### 서버 살펴보기
- 새 서버에서 만드는 스레드 수는 코드에서 한계를 명시하지 않으면 이론상으로 JVM이 허용하는 수까지 가능하다.
- 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이라면 너무 많은 사용자가 한꺼번에 몰릴시 시스템이 동작을 멈출수도 있다.
- 서버 코드가 지는 책임
  - 소켓 연결 관리
  - 클라이언트 처리
  - 스레드 정책
  - 서버 종료 정책

- 불행하게도 이모든 책임은 process가 진다.
- 즉 단일 책임 원칙을 위반한다.

### 결론
- 동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙도 지켰다.
- 동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

## 가능한 실행 경로

### 경로 수
- 가능한 경로 수를 계산하기 위해서는 자바 컴파일러가 생성한 바이트 코드를 살펴봐야 한다.
- 루프나 분기가 없는 명령N개를 스레드 T개가 차례로 실행한다면 가능한 경우의 수는 (NT)!/N!^T 과 같다.

### 심층 분석
- 원자적 연산이란, 중단이 불가능한 연산을 원자적 연산으로 정의한다.

- 바이트 코드를 보기 전에 아래 3가지 정의를 명심해야 한다.
  - 프레임
    1. 모든 메서드 호출에는 프레임이 필요하다.
    2. 프레임은 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역변수를 포함한다.
    3. 프레임은 호출 스,택을 정의할 때 사용하는 표준 기법이다.
  
  - 지역 변수
    1. 메서드 범위 내에 정의되는 모든 변수를 가리킨다.
    2. 정적 메서드를 제외한 모든 메서드는 기본적으로 this라는 지역변수를 갖는다.
    3. this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다.

  - 피연산자 스택
    1. JVM이 지원하는 명령 대다수는 매개변수를 받는다.
    2. 피연산자 스택은 이런 매개변수를 저장하는 장소다.
    3. 피연산자 스택은 표준 LIFO 자료구조다.

### 결론
- 어떤 연산이 안전하고 어떤 연산이 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.
- ++ 연산은 원자적 연산이라 오해하는 경우도 많은데, 아니다.

## 라이브러리를 이해하라

### Executor 프레임워크
- Excutor 프레임워크는 스레드 풀링으로 정교한 실행을 지원한다.
- Excutor 프레임워크는 스레드 풀을 관리하고 풀 크기를 자동으로 조정하녀, 필요하다면 스레드를 재사용한다.
- Excutor 프레임워크는 Runnable 인터페이스를 구현한 클래스와 Callable 인터페잇스를 구현한 클래스도 지원한다.

### 스레드를 차단하지 않는 방법
- 최신 프로세서는 차단하지 않고도 안정적인 값을 갱신한다.
- synchronized 키워드는 언제나 락을 건다. 둘째 스레드가 같은 값을 갱신하지 않더라도 무조건 락부터 건다.
- 스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발한다.

### 다중 스레드 환경에서 안전하지 않은 클래스
- 본질적으로 이러한 환경에서 안전하지 않은 클래스
  - SimpleDateFormat
  - 데이터베이스 연결
  - java.util 컨테이너 클래스
  - 서블릿


## 메서드 사이에 존재하는 의존성을 조심하라
- 스레드 하나가 코드를 실행한다면 문제가 없다. 하지만 스레드 코드 두개가 인스턴스 하나를 공유하거나, 각 스레드가 값을 가져와서 처리하되 정수하나를 단 한번만 처리해야하는 상황에서는 다르다.

### 실패를 용인한다.
- 때로는 실패해도 괜찮도록 프로그램을 조정할수있다.

### 클라이언트 기반 잠금
- 각 클라이언트는 synchronized 키워드를 이용해 객체에 락을 건다

### 서버 기반 잠금
- 코드 중복이 줄어든다.
- 성능이 좋아진다
- 스레드 정책이 하나다
- 공유 변수 범위가 줄어든다

## 작업처리량 높이기

### 작업 처리량 계산 - 단일 스레드 환경
- 스레드 하나가 N페이지를 처리한다면 걸리는 시간은 1.5초 * N이다.

### 작업 처리량 계산 - 다중 스레드 환경
- 순서에 무관하게 페이지를 읽어와 독립적으로 처리해도 괜찮다면 다중 스레드가 처리율을 높여줄지 모른다

## 데드락

데드락이 발생하려면 다음 네가지 조건을 모두 만족해야 한다.
- 상호 배제
- 잠금&대기
- 선점 불가
- 순환대기

### 상호 배제
- 여러 스레드가 한 자원을 공유하나 그자원이 여러 스레드가 동시에 사용하지 못하ㅕ 개수가 제한적이라면 상호 배제 조건을 만족한다.
- 예) 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등

### 잠금&대기
- 일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.

### 선점 불가
- 한스레드가 다른 스레드로부터 자원을 빼앗지 못한다.

### 순환대기
- 죽음의 포옹이라고도 한다.
- 서로가 가진 자원이 아닌 다른 스레드의 자원을 필요오 할때 발생한다.

### 상호 배제 조건 깨기
- 동시에 사용해도 괜찮은 자원을 사용한다.
- 스레드 수 이상으로 자원수를 늘린다.
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.

### 잠금&대기 조건 깨기
- 대기하지 않으면 데드락이 발생하지 않는다

### 선점불가 조건 깨기
- 다른 스레드로 부터 자원을 빼앗아 오는 방법이다

### 순환대기 조건 깨기
- 자원을 똑같은 순서로 할당하면 순환대기느 불가능해진다.

## 다중 스레드 코드 테스트

### 몬테 카를로 테스트
- 조율이 가능하게 유연한 테스트를 만든다.
- 스템을 배치할 플랫폼 전부에서 테스트를 돌린다.


## 스레드 코드 테스트를 도와주는 도구
- IBM은 Contest라는 도구를 내놓았다. 스레드에 안전하지 않는 코드에 보조 코드를 더해 실해할 가능성을 높여주는 도구다.
- Contest로 보조 코드를 추가하니 천만번에 한번정도 실패하던 코드가 서른번에 한번 정도 실패했다.

## 결론
- 다중 스레드 코드를 깨끗하게 유지하는 방법을 익혔다.

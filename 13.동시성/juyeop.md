## 동시성
- 동시성과 깔끔한 코드는 양립하기 어렵다.

### 동시성이 필요한 이유?
- 결합을 없애는 전략이다.
  + 무엇(what)과 언제(when)을 분리하는 전략임
  + 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아짐
  + 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 형성된 모습

#### 1. 서블릿 예시
- 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.

#### 2. 웹 사이트 정보 요약 예시
- 한 번에 한 사이트를 방문하는 대신 다중 스레드를 알고리즘을 이용하면 수집기 성능을 높일 수 있다.

즉, 구조적인 장점 뿐만 아니라 성능적인 장점도 뛰어나므로 동시성을 채택한다.

### 동시성에 대한 미신과 오해
- 항상 성능을 높여준다. (X)
    + 상황에 따라 성능을 높여줌
        * 대기 시간이 아주 길어 여러 스레드가 프로세스를 공유할 수 있을 경우
        * 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우

- 동시성을 구현해도 설계는 변하지 않는다. (X)
    + 동시성은 무엇과 언제를 분리하므로 단일 스레드 시스템과 설계가 다름

- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. (X)
    + 컨테이너 동작방식, 공유 자원 동시 수정, 데드락 등과 같은 문제를 피할 수 있는 방법을 알아야 함

### 동시성에 대한 타당한 생각 몇 가지
- 다소 부하를 유발한다. (O)
    + 코드를 더 짜야 함

- 복잡하다. (O)
    + 간단한 문제라도 동시성에서는 복잡함

- 일반적으로 동시성 버그는 재현하기 어렵다. (O)
    + 일회성 문제로 여기고 무시하기 쉬움

- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다. (O)

### 동시성 구현의 난관
``` kotlin
class Juyeop {
    var age: Int = 20
    
    fun getNextAge() = ++age
}
```
- 두 스레드에 동일한 인스턴스 하나를 공유하고 각 스레드에서 getNextAge() 메서드를 호출하면 경우의 수는 아래와 같다.
  + A 스레드: 21, B 스레드: 22, 최종적으로 age는 22 (A 스레드가 먼저 메서드를 호출한 경우)
  + A 스레드: 22, B 스레드: 21, 최종적으로 age는 22 (B 스레드가 먼저 메서드를 호출한 경우)
  + A 스레드: 21, B 스레드: 21, 최종적으로 age는 21 (A, B 스레드가 동시에 메서드를 호출한 경우)

- A, B 스레드가 getNextAge 메서드를 실행하는 잠재적인 경로는 최대 12,870개에 달한다.
  + age 변수를 Int에서 Long으로 변경하면 조합 가능한 경로 수는 2,704,156개로 증가함

### 동시성 방어 원칙

#### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 동시성 관련 코드는 다른 POJO 코드와 분리해야 한다는 뜻이다.
- 동시성을 구현할 때 아래 몇 가지를 고려해라.
  + 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있음
  + 독자적인 나관이 있으며 다른 코드의 난관에 비해 훨씬 어려움
  + 별의별 방식으로 실패함, 동시성 하나만으로도 충분히 어려움

결론: 동시성 코드는 다른 코드와 분리하라.

#### 2. 자료 범위를 제한하라
- 객체 하나를 공유한 후 동일 필드를 수정하면 두 스레드가 서로를 간섭하므로 예상치 못한 결과를 내놓는다.
- 공유 객체를 사용하는 코드 내 임계영역을 `synchronized` 키워드로 보호하라.

결론: 자료를 캡슐화하고, 공유 자료와 임계영역을 최대한 줄이고, 보호할 임계영역을 잘 확인해라.

#### 3. 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 사본 생성과 가비지 컬렉션에 드는 부하가 더 적을 가능서이 크다.

#### 4. 스레드는 가능한 독립적으로 구현하라.
- 자신만의 세상에 존재하는 스레드를 구현한다.
- 즉, 다른 스레드와 자료를 공유하지 않는다.
- 각 스레드는 클라이언트 요청 하나를 처리한다.
- 로컬 변수만 사용한다면 동기화 문제를 일으킬 가능성은 저무하다.

결론: 독자적인 스레드로, 가능하다면 다른 프로세스에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

### 라이브러리를 이해하라
- 자바 5 이야기 (ConcurrentHashMap)
결론: 언어가 제공하는 클래스를 검토하라, 동시성을 지원하는 클래스는 어떤 것이고 지원하지 않는 것은 또 어떤 것인지 확인해라.

### 실행 모델을 이해하라
- 한정된 자원 (Bound Resource)
- 상호 배제 (Mutual Exclusion)
  + 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킴
  + 자바의 `synchronized`와 유사하겠음
- 기아 (Starvation)
  + 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다림
  + 항상 작업 처리 시간이 짧은 스레드에게 우선순위를 준다면 긴 스레드는 기아 상태에 빠짐
- 데드락 (Deadlock)
  + 모든 스레드가 각자 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 진행하지 못함, 교착상태
- 라이브락 (Livelock)
  + 락을 거는 단계에서 각 스레드가 서로를 방해함
  + 락을 거는 과정에서 스레드는 계속 작업을 수행하려고 해서 공명이 일어나며 오랫동안 또는 영원히 진행이 안되게 됨

#### 1. 생산자-소비자
- 생산자 스레드는 정보를 생성해 버퍼나 대기열에 넣는다.
- 소비자 스레드는 대기열에서 정보를 가져와 사용한다.
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
- P는 대기열에 빈 공간이 있어야 정보를 채우므로 빈 공간이 생길 때까지 기다린다.
- C는 대기열에 정보가 있어야지 가져오므로 정보가 채워질 때까지 기다린다.
- 대기열을 올바르게 사용하기 위해 P와 S는 서로에게 시그널을 보낸다.
- 간혈적으로 P와 S가 모두 작업이 가능한 상황임에도 불구하고 서로의 시그널을 기다리는 현상이 발생할 수 있다.
  + 왜 이런 현상이 생길 수 있는지 모르겠음
  + 관련해서 논의가 필요함

#### 2. 읽기-쓰기
- 읽기 스레드는 공유 자원을 읽고, 쓰기 스레드는 해당 공유 자원을 갱신한다고 하자.
- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다.
  + 읽기 스레드에게 유리한 경우
  + 빨리 처리할려고 작업 처리 시간이 짧은 스레드에게만 우선순위를 부여하기 때문
- 갱신을 허용하면 처리율에 영향을 미친다.
  + 쓰기 스레드에게 유리한 경우
  + 쓰기 스레드가 버퍼를 갱신하는 동안 읽기 스레드는 버퍼를 읽지 못하므로
- 간단한 전략은 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다.
  + 무슨 말인지 이해가 되지 않음
  + 나 좀 이해시켜줘...

#### 3. 식사하는 철학자들
<img src="https://velog.velcdn.com/images/spolice/post/67349cd6-d752-4f9f-9c61-2b3ecb0a2c20/image.png">
- 이런 상황에서 구조를 주의깊게 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 객체 하나에는 메서드 하나만 사용하라.
- 다만, 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다.
  + 클라이언트에서 잠금: 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다, 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  + 서버에서 잠금: 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
  + 연결 서버: 잠금을 수행하는 중간 단계를 생성한다. '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경하지 않는다.

### 동기화하는 부분을 작게 만들어라
- 자바에서 `synchronized` 키워드를 사용하면 락을 설정한다.
- 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다.

### 올바른 종료 코드는 구현하기 어렵다
- 가장 흔히 발생하는 문제가 데드락이다.
- 만약 자식 스레드 중 하나가 데드락에 걸렸다면? 부모 스레드는 영원히 기다리고, 시스템은 영원히 종료하지 못한다.
- 깔끔하게 종료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현하기 바란다.
결론: 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라.

### 스레드 코드 테스트하기
- 문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다.

#### 1. 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
- 일회성 문제란 존재하지 않는다고 가정하는 편이 안전하다.
- 그렇다고 해서 '일회성' 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다.

#### 2. 다중 스레드를 고려하지 않는 순차 코드부터 제대로 돌게 만들자.
- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다. (POJO)
결론: 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅 하지 마라.

#### 3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.
- 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
- 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
- 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
- 반복 테스트가 가능하도록 테스트 케이스를 작성한다.
결론: 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.

#### 4. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성해라.
- 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민한다.

#### 5. 프로세서 수보다 많은 스레드를 돌려보라
- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

#### 6. 다중 플랫폼에서 돌려보라
- 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있다.
- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
- 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.

#### 7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 스레드 코드는 오류 찾기가 어렵다.
- wait, sleep, yield, priority 등과 같은 메서드를 추가해 코드를 다양한 순서로 실행한다.
- 잘못된 코드라면 가능한 초반에 그리고 가능한 자주 실패하는 편이 좋다.

##### 7-1. 직접 구현하기
- 특별히 까다로운 코드를 테스트할 때 적합하다.

``` java
public synchronized String nextUrlOrNull() {
    if (hasNext()) {
        String url = urlGenerator.next();
        Thread.yield(); // 테스트를 위해 추가됨
        updateHasNext();
        return url;
    }
    return null
}
```

- 다만, 직접 구현하기는 아래와 같은 고민이 있다.
  + 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다.
  + 어떤 함수를 어디서 호출해야 적당한지 어떻게 알까?
  + 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
  + 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다. 사실상 드러나지 않을 확률이 더 높다.

- 스레드를 전혀 모르는 POJO와 스레드를 제어하는 클래스로 프로그램을 분활하면 보조 코드를 추가할 위치를 찾기가 쉬워진다.

##### 7-2. 자동화
- 보조 코드를 자동으로 추가하려면 AOF(Aspect-Oriented Framework), CGLIB, ASM 등과 같은 도구를 사용한다.

``` java
public class ThreadJigglePoint {
    public static void jiggle() {}
}
```

``` java
public synchronized String nextUrlOrNull() {
    if (hasNext()) {
        ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null
}
```
- ThreadJigglePoint.jiggle() 호출은 무작위로 sleep이나 yield를 호출한다, 때로는 아무 동작도 하지 않는다.
- 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서다.
- 좋은 테스트 케이스와 흔들기 기법은 오류가 드러날 확률을 크게 높여준다.

### 결론
- SRP를 준수한다.
- POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리한다.
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
- 사용하는 라이브러리의 기능과 기본 알고리즘을 이해한다.
- 락이 필요하지 않는 코드는 락을 하지 않는다.
- 공유하는 객체 수와 범위를 최대한 줄인다.
- 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.

# 동시성

## 동시성이 필요한 이유
- 동시성은 결합을 없애는 전략이기 때문. '무엇'과 '언제'를 분리하는 전략이다.
- 결합을 분리하면 앱의 구조와 효율이 극적으로 나아지기 때문.
- 사용자가 많을시 한번에 한 사용자를 처리하는 시스템일 경우 사용자가 늘어날수록 시스템이 응답하는 속도는 느려진다.

### 미신과 오해
- 동시성은 항상 성능을 높여준다.
  - 동시성은 때로 성능을 높여준다.
- 동시성을 구현해도 설계는 변하지 않는다
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
  - 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 컨테이너가 어떻게 동작하는지, 어떻게 동시수정이 되는지, 데드락 등과 같은 문제를 피할 수 있는지를 알아야 한다.

### 동시성의 타당한 생각
- 동시성은 다소 부하를 유발시킨다.
- 동시성은 복잡하다
- 일반적으로 동시성 버그는 재현하기 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계전략을 재고해야 한다.


## 난관
```public class x {
  private int lastIdUsed;
  
  public int getNextId() {
    return ++lastIdUsed;
  }
```
lastIdUsed = 42

- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 44을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 43이 된다.
- 두 스레드가 getNextId메서드를 실행하는 잠재적인 경로는 최대 12870개에 달한다.
- 변수를 int에서 long으로 변경하면 조합 가능한 경로 수는 2704156개로 증가한다.


## 동시성 방어 원칙

### 단일 책임 원칙 (Single Responsibility Principle)
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 동시성을 구현할때 고려해야 할 몇가지 원칙
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드는 독자적인 난관이 있다.
  - 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.
- 권장사항 : 동시성 코드는 다른 코드와 분리하라.

### 자료 범위를 제한하라
- 공유객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라.
- 공유자료를 수정하는 위치가 많을수록 다음 가능성도 커진다.
  - 보호할 임계영역을 빼먹는다.
  - 모든 임계영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
  - 버그가 찾기 어려워진다.
- 권장사항 : 자료를 캡슐화하라. 공유자료를 최대한 줄여라.

### 자료 사본을 사용하라.
- 공유자료를 줄이려면 처음부터 공유하지 않는것이 중요하다.
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 아주 낮아 진다.

### 스레드는 가능한 독립적으로 구현하라.
- 자신만의 세상에 존재하는 스레드를 구현한다. 즉, 다른 스레드와 자료를 공유 하지 않는다.
- 각 스레드는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- 권장사항 : 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.


## 라이브러리를 이해하라

### 스레드 환경에 대한 컬렉션
- java.util.concurrnet 패키지가 제공하는 클래스는 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다.
- ConcurrnetHashMap은 거의 모든 상황에서 HashMap보다 빠르다. 동시 읽기/쓰기를 지원하며 자주 사용하는 복합연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공한다.
- 좀더 복잡한 동시성 설계를 지원하고자 자바5에는 다른 클래스도 추가되었다.
  - ReentrantLock : 한 메서드에서 잠그고 다른 메서드에서 푸는 lock이다.
  - Semaphore : 전형적인 세마포다. 개수가 있는 lock이다.
  - CountDownLatch : 지정한 수만큼 이벤트가 발생하고 나서야 대기중인 스레들르 모두 해제하는 lock이다.


## 실행 모델을 이해하라
- 다중 스레드 앱을 분류하는 방식
  - 한정된 자원 : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.
  - 상호 배제: 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
  - 기아: 한스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
  - 데드락: 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
  - 라이브락: 락을 거는 단계에서 각 스레드를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

### 생산자(P)-소비자(C)
- P가 정보를 생산해 버퍼나 대기열에 넣는다.
- C가 대기열에서 정보를 가져와 사용한다.
- P와 C가 사용하는 대기열은 한정된 자원이다.
- P는 대기열에 빈공간이 있어야 정보를 채우므로 빈 공간이 생길때까지 기다린다.
- 대기열을 올바로 사용하고자 P와 C는 서로에게 시그널을 보낸다.
- 잘못하면 P와 C가 둘 다 진행가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴수도 있다.

### 읽기-쓰기
- 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 이 공유 자원을 이따금 갱신한다고 하자. 이런 경우 처리율이 문제가 된다
- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다.
- 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.
- 간단한 전략은 읽기 스레드가 없을때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다.

### 식사하는 철학자들
- 일상에서 접하는 대다수의 다중 스레드 문제는 각 알고리즘을 공부하고 해법을 직접 구현해봐라

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 클래스 하나에 동기화된 메서드가 여러개라면 구현이 올바른지 체크하라
- 공유 객체 하나에 여러 메서드가 필요한 상황이라면 다음 방법을 고려하라
  - 클라이언트에서 잠금
  - 서버에서 잠금
  - 연결 서버


## 동기화하는 부분을 작게 만들어라
- 자바에서 synchronized키워드를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다. 그러므로 여기저기서 synchronized 문을 남발하는 코드는 바람직하지 않다.
- 반면 임계영역은 반드시 보호해야한다.
- 필요 이상으로 임계영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다.


## 올바른 종료 코드는 구현하기 어렵다.
- 영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
- 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다.
- 깔끔하게 종료하는 다중스레드 코드를 짜야한다면 시간을 투자해 올바로 구현하기 바란다.
- 권장사항 : 종료코드를 개발초기부터 고민학고 동작하게 초기부터 구현하라.


## 스레드 코드 테스트하기

- 코드가 올바르다고 증명하기는 현실적으로 불가능하다.
- 테스트가 정확성을 보장하진 않지만 충분한 테스트는 위험성을 낮춘다.
- 권장사항 : 문제를 노출하는 테스트 케이스를 작성하라
- 고려해야할 지침
  - 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라.
  - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
  - 프로세서 수보다 많은 스레드를 돌려보라.
  - 다른 플랫폼으로 돌려보라.
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드 코드는 때때로 '말이 안되는' 오류를 일으킨다.
- 많은 개발자가 우주선, 하드웨어 문제, 단순한 일회성 문제로 치부하고 무시한다.
- 일회성 문제를 계속 무시한다면 잘못된 코드위에 코드가 계속 쌓인다.
- 권장사항 : 시스템 실패를 '일회성'이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다.
- 스레드가 호출하는 POJO를 만들어라. POJO는 스레드를 모른기 때문에 스레드 환경 밖에서 테스트가 가능하다.
- POJO에 넣는 코드는 많을수록 더 좋다.

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려해라.
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민해라

### 프로세서 수보다 많은 스레드를 돌려보라
- 시스템이 스레드를 스와핑할 때도 문제가 발생한다.
- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

### 다른 플랫폼에서 돌려보라
- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
- 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.
- 권장사항 : 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 흔히 스레드 코드는 오류를 찾기가 쉽지 않다.
- 스레드 버그가 산발적이고 우발적이고 재현이 어려운 이유는 코드가 실행되는 수천가지 경로중에 아주 소수만 실패하기 때문이다
- 보조코드를 추가해 코드가 실핼되는 순서를 바꿔준다.
  - Object.wait()
  - Object.sleep()
  - Object.yield()
  - Object.priority()

- 코드에 보조코드를 추가하는 방법
  - 직접 구현하기
  - 자동화

- 직접 구현하기
  - yield()를 삽입하면 코드가 실행되는 경로가 바뀐다.
  - 코드가 실패한다면 yield()를 추가했기 때문이 아니라 원래 잘못된 코드인데 증거가 드러났을 뿐이다.
  - 이 방법에는 여러가지 문제가 있다.
    - 보조 코드를 삽입할 적당한 위치를 직접 찾아야 한다.
    - 어떤 함수를 어디서 호출해야 하는지 어떻게 알까?
    - 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
    - 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다.
  
### 자동화
- 보조 코드를 자동으로 추가하려면 AOF, CGLIB, ASM등과 같은 도구를 사용한다.
- 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위해서다. 좋은 테스트 케이스와 흔들기 기법은 오류 드러날 확률을 크게 높여준다.

### 결론
- 다중 스레드는 올바로 구현하기 힘들다. 다중 스레드 코드를 작성해야 한다면 각별히 깨끗하게 코드를 짜야한다.
- SPR을 준수한다.
- POJO를 사용해 스레드를 아는 코드와 모르는 코드를 분리한다.
- 스레드 코드를 테스트 할때는 전적으로 스레드만 테스트한다.
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
- 사용하는 라이브러리와 기본 알고리즘을 이해한다.
- 특정 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악한다.
- 보호할 코드영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
- 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.
- 시간을 들여 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아진다.
- 스레드 코드는 출시하기 전까지 최대한 오랫동안 돌려봐야 한다.
- 깔끔한 접근 방식을 취한다면 코드가 올바로 돌아갈 가능성이 극적으로 높아진다.

# 동시성
- 객체는 처리의 추상화다. 스레드는 일정의 추상화다, 제임스 O. 코플리엔
- 동시성과 깔끔한 코드는 양립하기 어렵다.

## 동시성이 필요한 이유
- 동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접한다.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.

### 미신과 오해
- 다음은 동시성과 관련한 일반적인 미신과 오해다.
  - 동시성은 항상 성능을높여준다.
  - 동시성을 구현해도 설계는 변하지 않는다.
  -웹또는 EJB컨테이너를 사용하면 동시성을 이해할 필요가 없다.
- 반대로 다음은 동시성과 관련된 타당한 생각 몇 가지다.
  - 동시성은 다소 부하를 유발한다.
  - 동시성은 복잡하다.
  - 일반적으로 동시성 버그는 재현하기 어렵다.
  - 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

## 난관
``` kotlin
public class x {
  private int lastIdUsed;
  
  public int getNextId() {
    return ++lastIdUsed;
  }
}
```
결과는 셋중 하나다.
- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 44을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 43이 된다.
- 바이트 코드만 고려했을 때,두 스레드가 getNextId메서드를 실행하는 잠재적인 경로는 최대 12870개에 달한다.
- 변수는 int에서 long으로 변경하면 조합 가능한 경로 수는 2704156개로 증가한다.

## 동시성 방어 원칙
- 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술을 소개한다.

### 단일 책임 원칙
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻이다.
- 동시성을 구현할 때는 다음 몇 가지를 고려한다.
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
  - 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

### 자료 범위를 제한하라
- 코드 내 임계영역을 synchronized 키워드로 보호 함으로써 위에 문제를 해결하라고 권장한다.
- 이런 임계영역의 수를 줄이는 기술이 중요하다.
  - 보호할 임계영역을 빼먹는다. 그래서 공유 자료를 수정하는 모든 코드를 망가뜨린다
  - 모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복하다.
  - 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.

### 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 아주 낮아진다.
- 사본으로 딩기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

### 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현한다. 즉, 다른 스레드와 자료를 공유 하지 않는다.
- 각 스레드는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- 서블릿 코드가 로컬 변수만 사용한다면 서블릿이 동기화 문제를 일으킬 가능성이 전무하다.

## 라이브러리를 이해하라

### 스레드 환경에 안전한 컬렉션
- java.util.concurrent 패키지가 제공하는 클레스는 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다.
- ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다. 동시 읽기 쓰기를 지원하며, 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공한다.
- 좀 더 복잡한 동시성 설계를 지원하고자 자바 5에는 다른 클래스도 추가되었다
  - ReentrantLock: 한 메서드에서 잠그고 다른 메서드에서 푸른 락이다.
  - Semaphore: 전형적인 세마포다. 개수가 있는 락이다.
  - CountDownLatch: 지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제 하는 락이다. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.

## 실제 모델을 이해하라
- 다중 스레드 애플리케이션을 분류하는 방식은 여러 가지다. 몇 가지 기본 용어부터 이해하자.
  - 한정된 자원: 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터 베이스 연결등이 예제다.
  - 상호 배제: 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가르킨다.
  - 기아: 한스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
  - 데드락: 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
  - 라이브락: 락을 거는 단계에서 각 스레드를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

### 생산자-소비자
- 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
- 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
- 대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다.
- 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

### 읽기-쓰기
- 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만,쓰기 스레드가 이 공유 자원을 이따금 갱신한다고 하자. 이런 경우 처리율이 문제의 핵심이다.
- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다. 갱신을 허용하면 처리율에 영향을 미친다.
- 둘다 적절히 사용할려면 복잡한 군형잡기가 필요하다. 대개는 버퍼를 기다리느라 처리율이 떨어진다.
- 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다.
- 간단한 전략은 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다. 하지만 이 방법도 처리율이 떨어질수 있다.

### 식사하는 철하자들
- 각 철학자 왼쪽에는 포크가 놓였다. 식탁 가운데는 커다란 스파게티 한 접시가 놓였다.
- 철학자들은 배가 고프지 않으면 생각하며 시간을 보낸다. 배가 고프면 양손에 포크를 집어들고 스파게티를 먹는다.
- 양손에 포크를 쥐지 않으면 먹지 못한다. 
- 여기서 철학자를 스레드로 포크를 자원으로 바꿔 생각해보면, 많은 기업 애플리케이션에서 겪는 문제다.
- 주의해서 설계하지 않으면 데드락, 라이브락, 치리율 저하, 호율성 저하 등을 겪는다.

## 동기화하는 메서드 사이에 존해하는 의존성을 이해하라
- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그럴 때는 다음 세가지 방법을 고려한다.
  - 클라이언트에서 잠금: 클라에서 첫 메서드 호출전 까지 서버를 잠그고. 마지막 메서드 호출까지 유지한다.
  - 서버에서 잠금: 서버에다 서버를 잠금고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
  - 연결 잠금: 잠금을 수행하는 중간 단계를 생성한다. 서버에서 장금과 유사하지만 원래 서버는 변경하지 않는다.

## 동기화하는 부분을 작게 만들어라
- 자바에서 synchronized 키워드를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다. 그러므로 여기저기서 synchronized 문을 남발하는 코드는 바람직하지 않다.
- 반면 임계영역은 반드시 보호해야한다.
- 필요 이상으로 임계영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성는이 떨어진다.

## 올바른 종료 코드는 구현하기 힘들다.
- 영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
- 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다. 가장 흔히 발생하는 문제가 데드락이다.
- 깔끔하게 정료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현하기 바란다.

## 스레드 코드 테스트하기
- 코드가 올바르다고 증명하기는 현실적으로 불가능하다.
- 테스트가 정확성을 보장하지는 않는다. 그럼에도 충분한 테스트는 위험을 낮춘다.
- 스레드가 둘 이상으로 늘어나면 고려할 사항이 아주 많다. 아래에 몇가지 지침을 제시한다
  - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
  - 다중 스레드를 고려하지 않은 순차 코드로부터 제대로 돌게 만들자.
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼우 넣을 수 있도록 스레드 코드를 구현하라.
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
  - 프로세서 수보다 많은 스레드를 돌려보라.
  - 다른 플랫폼으로 돌려보라.
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드 코드는 때때로 말이 안되는 오류를 일으킨다.
- 대다수 개발자는 스레드가 다른 코드와 교류하는 방식을 직관적으로 이해하지 못한다. 스레드 코드에 잠입한 버그는 수천,아니 수백만 번에 한 번씩 드러나기도 한다.
- 그래서 대다수 개발자들은 단순한 일회성 문제로 치부하고 무시한다.
- 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다.

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
- 스레드 환경 밖에서 코드가 제대로 도는지 반드시 확인한다.
- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라.
- 다중 스레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라.
  - 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
  - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
  - 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.
- 스레드 개수를 조율하기 쉽게 만들고, 프로그램 도중에 개수를 변경하는 방법도 고려한다.
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민한다.

### 프로세서 수보다 많은 스레드를 돌려보라
- 시스템이 스레드를 스와핑할 때도 문제가 발생한다.
- 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.
- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

### 다른 플랫폼에서 돌려보라
- 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질수있다.
- 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다.
- 따라서 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.

### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 스레드 코드는 오류 찾기가 쉽지 않다.
- 이러한 오류들을 쉽게 일으키기 위해 보조 코드를 추가해 코드가 실행되는 순서를 바꿔준다. 
- 각 메서드는 스레드가 실행되는 순서에 영향을 미친다. 따라서 버그가 드러날 가능성도 높아진다.
- 코드에 보조 코드를 추가하는 방법은 두가지다.
  - 직접 구현하기
  - 자동화

### 직접 구현하기
- 코드에다 직접 wait, sleep, yield, priority함수를 추가한다. 특별히 까다로운 코드를 테스트 할때 적합하다.
- 이러한 코드들은 이전에 실패하지 않았던 코드가 실패할 가능성을 열어준다.
- 코드가 실패한다면 이 함수들을 추가했기 떄문이 아니다 원래 잘못된 코드인데 증거가 드러났을 뿐인다.
- 하지만 이방법에는 여러 가지 문제가 있다
  - 보조 코드를 삽입할 적정 위치를 직접 찾아야 한다.
  - 어떤 함수를 어디서 호출해야 적당한지 어떻게 알까?
  - 배포 환경에 보조 코드를 그대로 남겨두면 프로그램 성능이 떨어진다.
  - 무작위적이다. 오류가 드러날지도 모르고 드러나지 않을지도 모른다.
- 배포 환경이 아닌 테스트 환경에서 보조 코드를 실행할 방법이 필요하다. 실행 할때마다 설정을 바꿔줄 방법도 필요하다. 그래야 오류가 드러날 확률이 높아진다.

### 자동화
- 보조 코드를 자동으로 추가하려면 AOF, CGLIB, ASM등과 같은 도구를 사용한다.
- 배포 환경에서는 아무 행동 하지 않고 테스트 환경에서만 무작위로 nop, sleep이나 yield등을 수행하게 한다.
- 좋은 테스트 케이스와 흔들기 기법은 오류가 드러날 확률을 크게 높여준다.

## 결론
- 다중 스레드는 올바로 구현하기 힘들어 작성한다면 각별히 깨끗하게 코드를 짜야 한다.
- 무엇보다 먼저, SRP를 준수한다.
- POJO를 사용해 스레드를 아는 코드와 모르는 코드를 분리해 테스트 한다.
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다.
- 사용하는 라이브러리와 기본 알고리즘을 이해한다.
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
- 어떻게든 문제는 생긴다. 이러한 문제를 일회성문제로 여겨서는 안된다.

# 동시성
- 객체는 처리의 추상화다. 스레드는 일정의 추상화다, 제임스 O. 코플리엔
- 동시성과 깔끔한 코드는 양립하기 어렵다.

## 동시성이 필요한 이유
- 동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접한다.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.

### 미신과 오해
- 다음은 동시성과 관련한 일반적인 미신과 오해다.
  - 동시성은 항상 성능을높여준다.
  - 동시성을 구현해도 설계는 변하지 않는다.
  -웹또는 EJB컨테이너를 사용하면 동시성을 이해할 필요가 없다.
- 반대로 다음은 동시성과 관련된 타당한 생각 몇 가지다.
  - 동시성은 다소 부하를 유발한다.
  - 동시성은 복잡하다.
  - 일반적으로 동시성 버그는 재현하기 어렵다.
  - 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

## 난관
``` kotlin
public class x {
  private int lastIdUsed;
  
  public int getNextId() {
    return ++lastIdUsed;
  }
}
```
결과는 셋중 하나다.
- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 44을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 44이 된다.
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastIdUsed는 43이 된다.
- 바이트 코드만 고려했을 때,두 스레드가 getNextId메서드를 실행하는 잠재적인 경로는 최대 12870개에 달한다.
- 변수는 int에서 long으로 변경하면 조합 가능한 경로 수는 2704156개로 증가한다.

## 동시성 방어 원칙
- 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술을 소개한다.

### 단일 책임 원칙
- SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻이다.
- 동시성을 구현할 때는 다음 몇 가지를 고려한다.
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
  - 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다.
  - 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

### 자료 범위를 제한하라
- 코드 내 임계영역을 synchronized 키워드로 보호 함으로써 위에 문제를 해결하라고 권장한다.
- 이런 임계영역의 수를 줄이는 기술이 중요하다.
  - 보호할 임계영역을 빼먹는다. 그래서 공유 자료를 수정하는 모든 코드를 망가뜨린다
  - 모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복하다.
  - 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기 어려워진다.

### 자료 사본을 사용하라
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
- 공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 아주 낮아진다.
- 사본으로 딩기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.

### 스레드는 가능한 독립적으로 구현하라
- 자신만의 세상에 존재하는 스레드를 구현한다. 즉, 다른 스레드와 자료를 공유 하지 않는다.
- 각 스레드는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.
- 서블릿 코드가 로컬 변수만 사용한다면 서블릿이 동기화 문제를 일으킬 가능성이 전무하다.

## 라이브러리를 이해하라

### 스레드 환경에 안전한 컬렉션
- java.util.concurrent 패키지가 제공하는 클레스는 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다.
- ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다. 동시 읽기 쓰기를 지원하며, 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공한다.
- 좀 더 복잡한 동시성 설계를 지원하고자 자바 5에는 다른 클래스도 추가되었다
  - ReentrantLock: 한 메서드에서 잠그고 다른 메서드에서 푸른 락이다.
  - Semaphore: 전형적인 세마포다. 개수가 있는 락이다.
  - CountDownLatch: 지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제 하는 락이다. 모든 스레드에게 동시에 공평하게 시작할 기회를 준다.

## 실제 모델을 이해하라
- 다중 스레드 애플리케이션을 분류하는 방식은 여러 가지다. 몇 가지 기본 용어부터 이해하자.
  - 한정된 자원: 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터 베이스 연결등이 예제다.
  - 상호 배제: 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가르킨다.
  - 기아: 한스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
  - 데드락: 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.
  - 라이브락: 락을 거는 단계에서 각 스레드를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.

### 생산자-소비자
- 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
- 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
- 대기열을 올바로 사용하고자 생산자 스레드와 소비자 스레드는 서로에게 시그널을 보낸다.
- 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

### 읽기-쓰기
- 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만,쓰기 스레드가 이 공유 자원을 이따금 갱신한다고 하자. 이런 경우 처리율이 문제의 핵심이다.
- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다. 갱신을 허용하면 처리율에 영향을 미친다.
- 둘다 적절히 사용할려면 복잡한 군형잡기가 필요하다. 대개는 버퍼를 기다리느라 처리율이 떨어진다.
- 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다.
- 간단한 전략은 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다. 하지만 이 방법도 처리율이 떨어질수 있다.

### 식사하는 철하자들
- 각 철학자 왼쪽에는 포크가 놓였다. 식탁 가운데는 커다란 스파게티 한 접시가 놓였다.
- 철학자들은 배가 고프지 않으면 생각하며 시간을 보낸다. 배가 고프면 양손에 포크를 집어들고 스파게티를 먹는다.
- 양손에 포크를 쥐지 않으면 먹지 못한다. 
- 여기서 철학자를 스레드로 포크를 자원으로 바꿔 생각해보면, 많은 기업 애플리케이션에서 겪는 문제다.
- 주의해서 설계하지 않으면 데드락, 라이브락, 치리율 저하, 호율성 저하 등을 겪는다.

## 동기화하는 메서드 사이에 존해하는 의존성을 이해하라
- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
- 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다. 그럴 때는 다음 세가지 방법을 고려한다.
  - 클라이언트에서 잠금: 클라에서 첫 메서드 호출전 까지 서버를 잠그고. 마지막 메서드 호출까지 유지한다.
  - 서버에서 잠금: 서버에다 서버를 잠금고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다. 클라이언트는 이 메서드를 호출한다.
  - 연결 잠금: 잠금을 수행하는 중간 단계를 생성한다. 서버에서 장금과 유사하지만 원래 서버는 변경하지 않는다.

## 동기화하는 부분을 작게 만들어라
- 자바에서 synchronized 키워드를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
- 락은 스레드를 지연시키고 부하를 가중시킨다. 그러므로 여기저기서 synchronized 문을 남발하는 코드는 바람직하지 않다.
- 반면 임계영역은 반드시 보호해야한다.
- 필요 이상으로 임계영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성는이 떨어진다.

## 올바른 종료 코드는 구현하기 힘들다.
- 영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르다.
- 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다. 가장 흔히 발생하는 문제가 데드락이다.
- 깔끔하게 정료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현하기 바란다.

## 스레드 코드 테스트하기
- 코드가 올바르다고 증명하기는 현실적으로 불가능하다.
- 테스트가 정확성을 보장하지는 않는다. 그럼에도 충분한 테스트는 위험을 낮춘다.
- 스레드가 둘 이상으로 늘어나면 고려할 사항이 아주 많다. 아래에 몇가지 지침을 제시한다
  - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라.
  - 다중 스레드를 고려하지 않은 순차 코드로부터 제대로 돌게 만들자.
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼우 넣을 수 있도록 스레드 코드를 구현하라.
  - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
  - 프로세서 수보다 많은 스레드를 돌려보라.
  - 다른 플랫폼으로 돌려보라.
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

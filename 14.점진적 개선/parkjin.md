# 점진적인 개선

> 명령행 인수의 구문을 분석할 필요가 있을 때, 편리한 유틸리티가 없어서 직접 작성할 것을 결심   
> 새로 작성할 유틸리티를 Args라고 명명

<img width="500" src="https://user-images.githubusercontent.com/50200481/209465840-3f5430b6-ad47-4987-89dc-3ec6dda64ff7.png">

> 출처: Clean Code 도서

- **Args 클래스**
  - 생성자에 **형식 문자열**과 **인수 문자열**을 넘겨 Args 인스턴스를 생성
  - 첫번째 매개변수: 형식 또는 스키마를 지정하는 "l,p#,d*"
    - -l: Boolean
    - -p: Integer
    - -d: String 
  - 두 번째 매개변수: main으로 넘어온 명령행 인수 배열 자체
  - 생성자에서 ```ArgsException```이 발생하지 않는다면, 명령행 인수의 구문을 성공적으로 분석했으며 Args 인스턴스에 질의를 던져도 좋다는 의미
  - 인수 값을 가져오기 위해서는 ```getBoolean```, ```getInteger```, ```getString```등과 같은 메서드를 사용
  - 형식 문자열이나 명령행 인수 자체에 문제가 있다면 ```ArgsException```이 발생

## Args 구현
> 코드 생략, 책 참고하도록

- 자바를 사용하여 오류 코드 상수를 정의하는 단순한 개념을 구현하는데 코드가 너무 많이 필요함
- 새로운 인수 유형을 추가하는 방법이 명백함
- ArgumentMarshaler에서 새 클래스를 파생해 함수와 조건 처리한 해주면 끝임

## 어떻게 짰느냐고?
- 깨끗하고 우아한 프로그램을 한 방에 뚝딱 내놓으리라 기대하지 않음
- **프로그래밍은 과학보다 공예에 가까움**
- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다는 의미
- 대다수 신참 프로그래머는 돌아가는 프로그램을 목표로 잡고 돌아가면 다음 업무로 넘어가 그대로 버려둠
- 경험이 풍부한 전문 프로그래머라면 이런 행동이 전문가로서 자살 행위라는 사실을 잘 앎

## Args: 1차 초안
> 코드 생략, 책 참고하도록

- 돌아가지만 엉망인 코드
- 인스턴스 변수 개수, 의도를 파악하기 어려운 문자열, HashSet, TreeSet, try-catch-catch 블록 등의 지저분한 코드
- 단일 타입이었을 때는 엉망이지 않았으나, 타입을 두 가지 추가했을 뿐인데 코드가 엄청나게 지저분해지고 버그와 결함이 숨어있을지 모르는 코드로 변함

## 그래서 멈췄다
- 추가할 타입이 더 있었으나 코드가 훨씬 더 나빠질 것이 자명했음
- 따라서 코드를 유지보수하기 좋은 상태로 만들기엔 적기라 판단하여 리팩터링을 시작
- 타입을 추가할 때마다 생겨나는 중복 코드를 ArgumentMarshaler라는 개념을 추가하여 해결함

## 점진적으로 개선하다
> 코드 생략, 책 참고하도록

- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위
- 어떤 프로그램은 개선 전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문에 그저 그런 개선에서 결코 회복하지 못함
- 그래서 테스트 주도 개발(TDD)라는 기법을 사용함
- TDD는 언제 어느 때라도 시스템이 돌아가야 한다는 원칙을 따름
- 즉, TDD는 시스템을 망가뜨리는 변경을 허용하지 않음
- 변경 전후에 시스템이 똑같이 돌아간다는 사실을 확인하려면 언제든 실행이 가능한 자동화된 테스트 케이스가 필요함

## 결론
- 그저 돌아가는 코드는 심하게 망가지는 사례는 흔함
- 단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족함
- 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없음
- 나쁜 코드를 개선할 수 있으나 비용이 많이 듦
- 반면, 처음부터 깨끗하게 코드를 유지하는 것은 상대적으로 쉬움
- 그러므로 코드는 언제나 최대한 깔끔하고 단순하게 정리해야 함

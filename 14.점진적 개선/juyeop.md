## 점진적 개선
### Args 사용법
- 첫째 매개변수는 형식 또는 스키마를 지정한다.
  + -l은 부울
  + -p는 정수
  + -d는 문자열
- 둘째 매개변수는 main으로 넘어온 명령행 인수 배열 자체다.
- 인수 값을 가져오려면 `getBoolean`, `getInteger`, `getString` 등과 같은 메서드를 사용한다.

```kotlin
val arg = Args("l,p#,d*", args)
args.getBoolean('l')
args.getInt('p')
args.getString('d')
```

### Args 소감
- 자바는 정적 타입 언어라서 타입 시스템을 만족하려면 많은 단어가 필요하다.
- 루비, 파이썬, 스몰토크 등과 같은 언어를 사용했다면 프로그램이 훨씬 작아졌으리라.
  + 엉클밥 형이 루비로 작성한 버전 (https://github.com/unclebob/rubyargs/tree/master)
- 날짜 인수나 복소수 인수 등 새로운 인수 유형을 추가하는 방법이 명백하다.
- ArgumentMarshaler에서 새 클래스를 파생해서 구현하고 Args 클래스에서 getXXX 함수를 추가한 후 parseSchemaElement 함수에 else if 문만 추가하면 끝이다.

### Args 어떻게 짰느냐고?
- 더욱 중요하게는 여러분이 깨끗하고 우아한 프로그램을 한 방에 뚝딱 내놓으리라 기대하지 않는다.
- 프로그램은 과학보다 공예에 더 가깝다는 사실이다.
  + 나는 과학이 60%, 공예가 40% 라고 생각한다.
  + 다른 분들의 의견은 어떠신지? (스터디 질문)
- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다.
- 일단 프로그램이 돌아가면 다음 업무로 넘어간다, 돌아가는 프로그램은 그 상태가 어떻든 그대로 버려둔다.
- 경험이 풍부한 전문 프로그래머라면 이런 행동이 전문가로서 자살 행위라는 사실을 잘 안다.

### Args 1차 초안
- 'TILT'와 같은 희한한 문자열, HashSets와 TreeSets, try-catch-catch 블록 등 모두가 지저분한 코드에 기여하는 요인이다.
  + 나는 앞에서 봤던 Args 완성본보다 Args 1차 초안이 훨씬 코드 흐름을 따라가기 쉬웠던 것 같다.
  + 추상화가 덜 되어 있고 절차적으로 작성되어서 그런가?
  + 다른 분들의 의견은 어떠신지? (스터디 질문)

- 함수 이름이나 변수 이름을 선택한 방식, 어설프지만 나름대로 구조가 있다는 사실 등이 내노력의 증거다.
- 하지만 어느 순간 프로그램은 내 손을 벗어났다.
- 다만, Boolean 인수만 지원하던 초기 버전에서는 이정도 까지는 아니었다.
- 유지와 보수가 적당히 수월했던 코드가 버그와 결함이 숨어있을지도 모른다는 상당히 의심스러운 코드로 뒤바뀌어버렸다.

### 그래서 멈췄다
- 추가할 인수 유형이 적어도 두 개는 더 있었는데 그러면 코드가 훨씬 나빠지리라는 사실이 자명했다.
- 계속 밀어붙이면 프로그램은 어떻게든 완성하겠지만 그랫다가는 너무 커서 손대기 어려운 골칫거리가 생겨날 참이었다.
- 새 인수 유형을 추가하려면 주요 지점 세 곳에다 코드를 추가해야 한다는 사실을 이미 깨달았다.
  + 첫째, 인수 유형에 해당하는 HashMap을 선택하기 위해 스키마 요소의 구문을 분석한다.
  + 둘째, 명령행 인수에서 인수 유형을 분석해 진짜 유형으로 변환한다.
  + 셋째, getXXX 메서드를 구현해 호출자에게 진짜 유형을 반환한다.
- 인수 유형은 다양하지만 모두가 유사한 메서드를 제공하므로 클래스 하나가 적합하다 판단했다, 그래서 ArgumentMarshaler 개념 탄생 🎉

### 점진적으로 개선하다
- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다.





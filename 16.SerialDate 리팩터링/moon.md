# SerialDate 리팩터링
- 이 장에서는 바로 이 SerialDate라는 클래스를 탐험한다.
- 비판이 있어야 발전이 있다.

## 첫째, 돌려보자
- 테스트 케이스를 훑어보면 모든 경우를 점검하지 않는다.
- 클로버에 따르면 SerialDate에서 실행 가능한 문장 185개 중 실행하는 문장은 50% 였다.
- 그래서 독자는 직접 독자적으로 단위 테스트를 구현했다.
- 소스 코드는 484쪽 목록 B-4를 참조한다.
- SerialDate를 리팩터링 하면서 모든 테스트 케이스를 통과하게 코드를 손볼 작정이다.
- stringToWeekdayCode라는 메서드는 대소문자 구분 없이 모두 통과해야 한다고 봤다.
  - 그래서 equalsIgnoreCase로 바꿔주었다.
- tues와 thurs라는 약어를 지원해야 할지가 분명치 않았기 때문이다.
- getFollowingDayOfWeek 메서드에 버그 수정
  - 2004년 12월 25일이 토요일인 상태에서 getFollowingDayOfWeek 메서드를 호출하면 2005년 1월 1일 토요일이 나와야 하는데 2004년 12월 25일 토요일이 그대로 반환된다.
  - 전형적인 경계 조건 오류다.
  - if문에 >를 >=로 변경해주었다
- getTestNearstDayOfWeek메서드를 테스트하는 testGetNearestDayOfWeek 단위 테스트는 처음부터 이렇게 길지 않았다.
  - 처음 구현한 테스트 케이스가 실패하는 바람에 계속 추가하게 되었다.
  - 주석으로 처리한 코드를 살펴보면 실패하는 패턴이 보인다.
  - 알고리즘은 가장 가까운 날짜가 미래면 실패한다. 역시 경계 조건 오류다.
  - weekInMonthToString과 relativeToString에서 오류 문자열을 반환하는 대신 IllegalArgumentException을 던져 테스트를 통과시켰다.

## 둘째, 고쳐보자
- 코드를 고칠 때마다 나는 JCommon 단위 테스트와 저자가 짠 단위 테스트를 실행했다.
- 라이선스 정보, 저작권, 작성자, 변경 이력중 법적인 정보는 보존하고 나머지는 1960년대에 나온 방식으로 삭제해준다.
- 지저분한 import문은 *을 이용해 정리해준다.
- javadoc 주석은 HTML 태그를 사용한다. 한 소스 코드에 여러 언어를 사용하는게 탐탁치 않아 바꿀것이다.
  - 이 주석은 네 가지 언어를 사용해 모양새를 맞추기 어렵다.
  - 차라리 주석 전부를 <pre>로 감싸는 편이 좋다. 그러면 소스코드에 보이는 형식이 javadoc에 유지된다.
- 클래스 이름이 SerialDate인 이유
  - 클래스가 Serilizable에서 파생하니까? 아니다
  - 정답은 일련번호를 사용해 클래스를 구현했기 때문이다.
  - 여기서는 1899년 12월30일을 기준으로 경과한 날짜 수를 사용한다.
- 하지만 두 가지가 꺼림칙하다.
  - 첫째 일련번호라는 용어는 정확 하지 못하다 상대 오프셋이 더 정확하다. 더 서술적인 용어로는 서수가 있다.
  - 두번째는 SerialDate라는 이름의 추상화 수준이 올바르지 못하다고 생각한다. 그냥 Date가 더 좋아보인다.
- 하지만 이미 자바 라이브러리에는 Date라는 클래스가 너무 많다.
- 그러므로 Date가 최적이라 보기는 어렵다. 여러 모로 고민한 끝에 나는 DayDate를 사용하기로 했다.
- MonthConstats를 enum으로 정의해준다.
-
